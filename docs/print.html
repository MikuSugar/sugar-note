<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sugar-note</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="algorithm/index.html"><strong aria-hidden="true">1.</strong> 算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/index.html"><strong aria-hidden="true">1.1.</strong> leetcode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第233场周赛.html"><strong aria-hidden="true">1.1.1.</strong> 力扣第233场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第234场周赛.html"><strong aria-hidden="true">1.1.2.</strong> 力扣第234场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第235场周赛.html"><strong aria-hidden="true">1.1.3.</strong> 力扣第235场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第236场周赛.html"><strong aria-hidden="true">1.1.4.</strong> 力扣第236场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第237场周赛.html"><strong aria-hidden="true">1.1.5.</strong> 力扣第237场周赛</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">sugar-note</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<p>记录一些算法相关的笔记～</p>
<h1 id="leetcode"><a class="header" href="#leetcode">leetcode</a></h1>
<p>记录leetcode相关～</p>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a">题一 <a href="https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/">最大升序子数组和</a></a></h2>
<h3 id="描述"><a class="header" href="#描述">描述</a></h3>
<p>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。</p>
<p>子数组是数组中的一个连续数字序列。</p>
<p>已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。</p>
<p> <!-- more --></p>
<h3 id="思路"><a class="header" href="#思路">思路</a></h3>
<p>直接遍历求解，遍历时保存上一个值判断是否升序。</p>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public int maxAscendingSum(int[] nums) {
        int res=0;
        int sum=0;
        int pre=0;
        for (int num:nums)
        {
            if(num&gt;pre) sum+=num;
            else sum=num;
            res=Math.max(sum,res);
            pre=num;
        }
        return res;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a">题二 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">积压订单中的订单总数</a></a></h2>
<h3 id="描述-1"><a class="header" href="#描述-1">描述</a></h3>
<p>给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p>
<p>订单类型 orderTypei 可以分为两种：</p>
<p>0 表示这是一批采购订单 buy
1 表示这是一批销售订单 sell
注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p>
<p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p>
<p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 10^9 + 7 取余的结果。</p>
<h3 id="思路-1"><a class="header" href="#思路-1">思路</a></h3>
<p>用两个堆（优先队列）分别存储两种订单，按题目描述模拟即可。</p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<pre><code class="language-java">import java.util.PriorityQueue;

public class N2 {

    private final static int MOD=(int) (1e9+7);

    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue&lt;int[]&gt; sell=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        PriorityQueue&lt;int[]&gt; buy=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o2[1],o1[1]);
            return Integer.compare(o2[0],o1[0]);
        });

        for (int[] order:orders)
        {
            int pricei=order[0];
            int amount=order[1];
            int[] o=sell.poll();
            //buy
            if(order[2]==0)
            {
                while (!sell.isEmpty()&amp;&amp;sell.peek()[0]&lt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount){
                        o[1]-=amount;
                        amount=0;
                        sell.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];

                }
                if(amount&gt;0)buy.add(new int[]{pricei,amount});

            }
            //sell
            else {
                while (!buy.isEmpty()&amp;&amp;buy.peek()[0]&gt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount)
                    {
                        o[1]-=amount;
                        amount=0;
                        buy.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];
                }
                if(amount&gt;0)sell.add(new int[]{pricei,amount});
            }
        }

        long res=0L;
        while (!buy.isEmpty()){
            res+=buy.poll()[1];
            res%=MOD;
        }
        while (!sell.isEmpty()){
            res+=sell.poll()[1];
            res%=MOD;
        }
        return (int) res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a">题三 <a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">有界数组中指定下标处的最大值</a></a></h2>
<h3 id="描述-2"><a class="header" href="#描述-2">描述</a></h3>
<p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p>
<p>nums.length == n
nums[i] 是 正整数 ，其中 0 &lt;= i &lt; n
abs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1
nums 中所有元素之和不超过 maxSum
nums[index] 的值被 最大化
返回你所构造的数组中的 nums[index] 。</p>
<p>注意：abs(x) 等于 x 的前提是 x &gt;= 0 ；否则，abs(x) 等于 -x 。</p>
<h3 id="思路-2"><a class="header" href="#思路-2">思路</a></h3>
<ul>
<li>最大值的情况，从index处递减至1。</li>
<li>二分找出index处最大的值。</li>
</ul>
<h3 id="代码-2"><a class="header" href="#代码-2">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public static void main(String[] args) {
        System.out.println(new N3().maxValue(6, 1, 10));
    }

    public int maxValue(int n, int index, int maxSum) {
        int res=1;
        int left=res, right=maxSum;
        while (left&lt;=right) {
            int mid=(left+right)/2;
            if (check(mid, n, index, maxSum)) {
                res=mid;
                left=mid+1;
            } else right=mid-1;
        }
        return res;
    }

    private boolean check(int max, int n, int index, int maxSum) {
        int sum=0;
        int l=max,lIdx=index;
        while (l&gt;1&amp;&amp;lIdx&gt;=0)
        {
            sum+=l;
            if(sum&gt;maxSum)return false;
            l--;
            lIdx--;
        }
        if(lIdx&gt;=0)sum+=lIdx+1;
        if(sum&gt;maxSum)return false;
        sum-=max;
        int r=max,rIdx=index;
        while (r&gt;1&amp;&amp;rIdx&lt;n){
            sum+=r;
            if(sum&gt;maxSum)return false;
            r--;
            rIdx++;
        }
        if(rIdx!=n)sum+=(n-rIdx);
        // System.out.println(sum);
        return sum&lt;=maxSum;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a">题四 <a href="https://leetcode-cn.com/problems/count-pairs-with-xor-in-a-range/">统计异或值在范围内的数对有多少</a></a></h2>
<h3 id="描述-3"><a class="header" href="#描述-3">描述</a></h3>
<p>给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。</p>
<p>漂亮数对 是一个形如 (i, j) 的数对，其中 0 &lt;= i &lt; j &lt; nums.length 且 low &lt;= (nums[i] XOR nums[j]) &lt;= high 。</p>
<h3 id="思路-3"><a class="header" href="#思路-3">思路</a></h3>
<p>待补充</p>
<h3 id="代码-3"><a class="header" href="#代码-3">代码</a></h3>
<p>待补充</p>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-234/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></a></h2>
<h3 id="描述-4"><a class="header" href="#描述-4">描述</a></h3>
<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>
<p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123 34 8 34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;</code>、<code>&quot;34&quot;</code>、<code>&quot;8&quot;</code> 和 <code>&quot;34&quot;</code> 。</p>
<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>
<p>如果两个整数的 <strong>不含前导零</strong> 的十进制表示不同，则认为这两个整数也不同。</p>
<p> <!-- more --></p>
<h3 id="思路-4"><a class="header" href="#思路-4">思路</a></h3>
<p>一次遍历，将数字存入Set中，注意前导零。</p>
<h3 id="代码-4"><a class="header" href="#代码-4">代码</a></h3>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Set;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:16 上午
 */
public class N1 {
    public int numDifferentIntegers(String word) {
        int idx=0;
        char[] strs=word.toCharArray();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        while (idx&lt;word.length())
        {
            while (idx&lt;word.length()&amp;&amp;!Character.isDigit(strs[idx]))idx++;
            StringBuilder sb=new StringBuilder();
            while (idx&lt;word.length()&amp;&amp;strs[idx]=='0')idx++;
            while (idx&lt;word.length()&amp;&amp;Character.isDigit(strs[idx]))
            {
                sb.append(strs[idx]);
                idx++;
            }
            if(sb.length()==0&amp;&amp;idx&gt;=1&amp;&amp;strs[idx-1]=='0')sb.append(&quot;0&quot;);
            if(sb.length()!=0)set.add(sb.toString());
        }
        return set.size();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a">题二 <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></a></h2>
<h3 id="描述-5"><a class="header" href="#描述-5">描述</a></h3>
<p>给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。</p>
<p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p>
<p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]
如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]
然后将 arr 赋值给 perm 。</p>
<p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p>
<h3 id="思路-5"><a class="header" href="#思路-5">思路</a></h3>
<p>直接按题目要求模拟。</p>
<h3 id="代码-5"><a class="header" href="#代码-5">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public static void main(String[] args) {
        System.out.println(new N2().reinitializePermutation(4));
    }
    public int reinitializePermutation(int n) {
        int[] arr=new int[n];
        int[] tmp=new int[n];
        for (int i=0;i&lt;n;i++)arr[i]=i;
        for (int res=1;res&lt;4;res++)
        {
            //System.out.println(Arrays.toString(arr));
            for (int i=0;i&lt;n;i++)
            {
                if(i%2==0) tmp[i]=arr[i/2];
                else if(i%2==1) tmp[i]=arr[n/2+(i-1)/2];
            }
            System.arraycopy(tmp, 0, arr, 0, n);
            boolean flag=true;
            for (int i=0;i&lt;n;i++)
            {
                if(arr[i]!=i){
                    flag=false;
                    break;
                }
            }
            if(flag)return res;
        }
        return -1;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a">题三 <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></a></h2>
<h3 id="描述-6"><a class="header" href="#描述-6">描述</a></h3>
<p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p>
<p>比方说，字符串 &quot;(name)is(age)yearsold&quot; 中，有 两个 括号对，分别包含键 &quot;name&quot; 和 &quot;age&quot; 。
你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p>
<p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p>
<p>将 keyi 和括号用对应的值 valuei 替换。
如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 &quot;?&quot; 替换（不需要引号）。
knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p>
<p>请你返回替换 所有 括号对后的结果字符串。</p>
<h3 id="思路-6"><a class="header" href="#思路-6">思路</a></h3>
<ul>
<li>将knowledge变为map方便使用</li>
<li>一次遍历，解析出括号内的key</li>
</ul>
<h3 id="代码-6"><a class="header" href="#代码-6">代码</a></h3>
<pre><code class="language-java">import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:17 上午
 */
public class N3 {

    public String evaluate(String s, List&lt;List&lt;String&gt;&gt; knowledge) {
        Map&lt;String,String&gt; map=new HashMap&lt;&gt;(knowledge.size()*2+5);
        for (List&lt;String&gt; know:knowledge)map.put(know.get(0),know.get(1));
        StringBuilder res=new StringBuilder();
        char[] strs=s.toCharArray();
        int idx=0;
        while (idx&lt;strs.length)
        {
            while (idx&lt;strs.length&amp;&amp;strs[idx]!='(') res.append(strs[idx++]);
            StringBuilder key=new StringBuilder();
            idx++;
            while (idx&lt;strs.length&amp;&amp;strs[idx]!=')') key.append(strs[idx++]);
            idx++;
            if(key.length()&gt;0)res.append(map.getOrDefault(key.toString(),&quot;?&quot;));
        }
        return res.toString();
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a">题四 <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></a></h2>
<h3 id="描述-7"><a class="header" href="#描述-7">描述</a></h3>
<p>给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：</p>
<p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。
n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。
请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。</p>
<p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n 。</p>
<h3 id="思路-7"><a class="header" href="#思路-7">思路</a></h3>
<p>这题一开始想复杂了，总想着把这个正整数找出来。其实这题不需要把这个正整数找出来。</p>
<p>对num进行质因数分解</p>
<pre><code>num=a1^k1*a2^k2.....
</code></pre>
<p>按题目要求可得</p>
<pre><code>k1+k2+.....&lt;=primeFactors
</code></pre>
<p>好因子必须包含有</p>
<pre><code>a1*a2*....
</code></pre>
<p>这个因数。</p>
<p>题目是求好因子数目的最大化的，也就是求</p>
<pre><code>k1*k2*...
</code></pre>
<p>的最大值</p>
<p>如何拆才能尽可能最大，尽可能拆成3。</p>
<p>选择3的理由如下：</p>
<p>依据<strong>均值不等式</strong>可得拆分成想等的值的时候乘积最大。</p>
<p>如果对n进行x份等值拆分可得y=(n/x)^x</p>
<p>可得x=e时，y最大。</p>
<p>最接近e的整数为3。</p>
<h3 id="代码-7"><a class="header" href="#代码-7">代码</a></h3>
<pre><code class="language-java">public class N4 {

    private final static int MOD=(int) (1e9+7);

    public int maxNiceDivisors(int primeFactors) {
        if (primeFactors&lt;=3) return primeFactors;
        if (primeFactors%3==1) return (int) (powMod(3, (primeFactors-4)/3, MOD)*4%MOD);
        if (primeFactors%3==2) return (int) (powMod(3, primeFactors/3, MOD)*2%MOD);
        return (int) (powMod(3, primeFactors/3, MOD));
    }
    //快速幂
    long powMod(long a, long b, final long mod) {
        if (b==0) return 1L;
        long res=powMod(a, b/2, mod)%mod;
        if (b%2==0) return res*res%mod;
        return res*res*a%mod;
    }

}
</code></pre>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/truncate-sentence/">截断句子</a></a></h2>
<h3 id="描述-8"><a class="header" href="#描述-8">描述</a></h3>
<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>
<ul>
<li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code> 都是句子。</li>
</ul>
<p>给你一个句子 <code>s</code> 和一个整数 <code>k</code> ，请你将 <code>s</code> <strong>截断</strong> ，使截断后的句子仅含 <strong>前</strong> <code>k</code> 个单词。返回 <strong>截断</strong> <code>s</code>后得到的句子。</p>
<p> <!-- more --></p>
<h3 id="思路-8"><a class="header" href="#思路-8">思路</a></h3>
<ul>
<li>按空格切分句子获得单词</li>
<li>按题目要求拼成截断后的句子</li>
</ul>
<h3 id="代码-8"><a class="header" href="#代码-8">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public String truncateSentence(String s, int k) {
        String[] strs=s.split(&quot; &quot;);
        StringBuilder sb=new StringBuilder();
        for (int i=0;i&lt;k;i++)sb.append(strs[i]).append(&quot; &quot;);
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a">题二 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></a></h2>
<h3 id="描述-9"><a class="header" href="#描述-9">描述</a></h3>
<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p>
<p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>
<p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>
<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>
<p>返回上面描述的答案数组 <code>answer</code> 。</p>
<h3 id="思路-9"><a class="header" href="#思路-9">思路</a></h3>
<p>把日志记录存在</p>
<pre><code class="language-java">Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
</code></pre>
<p>Key 是用户ID，Value存的是活跃时间的集合。</p>
<p>接着遍历map即可得到答案。</p>
<h3 id="代码-9"><a class="header" href="#代码-9">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int[] findingUsersActiveMinutes(int[][] logs, int k) {
        Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
        for (int[] log:logs){
            if(! map.containsKey(log[0]))map.put(log[0],new HashSet&lt;&gt;());
            map.get(log[0]).add(log[1]);
        }
        int[] res=new int[k];
        for (Map.Entry&lt;Integer,Set&lt;Integer&gt;&gt; e:map.entrySet()){
            res[e.getValue().size()-1]++;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a">题三 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/minimum-absolute-sum-difference/">绝对差值和</a></a></h2>
<h3 id="描述-10"><a class="header" href="#描述-10">描述</a></h3>
<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>
<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>
<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>
<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><code>|x|</code> 定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li>
<li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li>
</ul>
<h3 id="思路-10"><a class="header" href="#思路-10">思路</a></h3>
<ul>
<li>先求出绝对差值和。</li>
<li>对每一个位置idx的nums1[idx]尝试替换成最接近nums2[idx]的值</li>
<li>通过二分查找num1中最接近nums2[idx]的值</li>
<li>遍历所有idx</li>
</ul>
<h3 id="代码-10"><a class="header" href="#代码-10">代码</a></h3>
<pre><code class="language-java">public class N3 {

    private final static int MOD=(int) (1e9+7);

    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long sum=0L;
        long min=0L;
        for (int i=0;i&lt;nums1.length;i++)
        {
            sum+=Math.abs(nums1[i]-nums2[i]);
        }
        int[] arr=new int[nums1.length];
        System.arraycopy(nums1, 0, arr, 0, arr.length);
        min=sum;

        Arrays.sort(arr);

        for (int i=0;i&lt;nums1.length;i++)
        {
            int idx=find(nums2[i],arr);
            for (int j=Math.max(0,idx-2);j&lt;=Math.min(idx+2,arr.length-1);j++)
            {
                long tmp=sum-Math.abs(nums1[i]-nums2[i])+Math.abs(arr[j]-nums2[i]);
                min=Math.min(min,tmp);
            }
        }
        return (int) (min%MOD);

    }

    private int find(int tar, int[] arr) {
        if(tar&lt;=arr[0])return 0;
        if(tar&gt;=arr[arr.length-1])return arr.length-1;
        int left=0,right=arr.length-1;
        int res=right;
        while (left&lt;=right){
            int mid=(left+right)/2;
            if(arr[mid]==tar)return mid;
            if(arr[mid]&gt;tar){
                res=mid;
                right=mid-1;
            }
            else left=mid+1;
        }
        return res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a">题四 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></a></h2>
<h3 id="描述-11"><a class="header" href="#描述-11">描述</a></h3>
<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>
<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>
<ul>
<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>
</ul>
<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>
<ul>
<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,**2**,4,1,**5**,**10**]</code> 的一个子序列。</li>
</ul>
<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>
<h3 id="思路-11"><a class="header" href="#思路-11">思路</a></h3>
<ul>
<li>
<p>预计算算出这个范围内数的所有因数</p>
</li>
<li>
<p>如果一个序列中能被K整除有m个，被tk(t&gt;1,且t为整数)整除的数也有m个，那么如果k是一个序列的公约数，tk也是这个序列的公约数。</p>
<p>所以能被K整除个数不等于能被tk整除个数，那么k是一个最大公约数。</p>
</li>
</ul>
<h3 id="代码-11"><a class="header" href="#代码-11">代码</a></h3>
<pre><code class="language-java">public class N4 {
    private final static int MAX=2*100000+1;
    private final static List&lt;Integer&gt;[] factors=new List[MAX];
    private final static int[] book=new int[MAX];
    static{
        //预计算
        for (int i=1;i&lt;MAX;i++)factors[i]=new ArrayList&lt;&gt;();
        for (int i=1;i&lt;MAX;i++){
            for (int j=i;j&lt;MAX;j+=i){
                factors[j].add(i);
            }
        }
    }

    public int countDifferentSubsequenceGCDs(int[] nums) {
        int max=0;
        for (int i:nums)max=Math.max(max,i);
        Arrays.fill(book,0);
        for (int num:nums){
            for (int factor:factors[num]){
                book[factor]++;
            }
        }

        int res=0;
        for (int i=max;i&gt;=1;i--){
            if(book[i]==0)continue;
            boolean flag=true;
            for (int j=i*2;j&lt;=max;j+=i){
                if(book[i]==book[j]){
                    flag=false;
                    break;
                }
            }
            if(flag)res++;
        }
        return res;

    }

}
</code></pre>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a">题一 <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></a></h2>
<h3 id="描述-12"><a class="header" href="#描述-12">描述</a></h3>
<p>已知函数 signFunc(x) 将会根据 x 的正负返回特定值：</p>
<p>如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。</p>
<p>返回 signFunc(product) 。</p>
<p> <!-- more --></p>
<h3 id="思路-12"><a class="header" href="#思路-12">思路</a></h3>
<p>本题可以转换成求负数个数。</p>
<h3 id="代码-12"><a class="header" href="#代码-12">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int arraySign(int[] nums) {
        int cnt1=0;
        for (int i:nums)
        {
            if(i==0)return 0;
            if(i&lt;0)cnt1++;
        }
        if(cnt1%2==0)return 1;
        return -1;
    }   
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a">题二 <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></a></h2>
<h3 id="描述-13"><a class="header" href="#描述-13">描述</a></h3>
<p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p>
<p>游戏遵循如下规则：</p>
<p>从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p>
<h3 id="思路-13"><a class="header" href="#思路-13">思路</a></h3>
<ul>
<li>看成队列</li>
<li>模拟游戏规则</li>
</ul>
<h3 id="代码-13"><a class="header" href="#代码-13">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int findTheWinner(int n, int k) {
        Queue&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();
        for (int i=1;i&lt;=n;i++){
            queue.add(i);
        }
        int cur=k;
        while (queue.size()&gt;1){
            cur--;
            int p=queue.poll();
            if(cur!=0)queue.add(p);
            else cur=k;
        }
        return queue.poll();
    }
}
</code></pre>
<h2 id="题三"><a class="header" href="#题三">题三</a></h2>
<h3 id="描述-14"><a class="header" href="#描述-14">描述</a></h3>
<p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p>
<p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p>
<p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>
<p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p>
<p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p>
<h3 id="思路-14"><a class="header" href="#思路-14">思路</a></h3>
<p>动态规划:</p>
<pre><code>dp[number][idx] 表示 在number跑道的idx位置到终点最少还需要几次
</code></pre>
<h3 id="代码-14"><a class="header" href="#代码-14">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int minSideJumps(int[] obstacles) {
        int[][] dp=new int[3][obstacles.length];
        for (int i=0;i&lt;3;i++) Arrays.fill(dp[i],-1);
        int res=slove(2, 0, obstacles, dp);
        return res;
    }

    private int slove(int number, int idx, int[] obstacles, int[][] dp) {
        if(dp[number-1][idx]!=-1)return dp[number-1][idx];
        int res=Integer.MAX_VALUE&gt;&gt;1;
        if(idx==obstacles.length-1)return 0;
        if(obstacles[idx+1]!=number)res=slove(number,idx+1,obstacles,dp);
        else {
            for (int i=1;i&lt;=3;i++)
            {
                if(obstacles[idx]==i||obstacles[idx+1]==i)continue;
                res=Math.min(res,1+slove(i,idx,obstacles,dp));
            }
        }
        return dp[number-1][idx]=res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a">题四 <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></a></h2>
<h3 id="描述-15"><a class="header" href="#描述-15">描述</a></h3>
<p>给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。</p>
<p>MK 平均值 按照如下步骤计算：</p>
<p>如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。
从这个容器中删除最小的 k 个数和最大的 k 个数。
计算剩余元素的平均值，并 向下取整到最近的整数 。
请你实现 MKAverage 类：</p>
<p>MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。
void addElement(int num) 往数据流中插入一个新的元素 num 。
int calculateMKAverage() 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。</p>
<h3 id="思路-15"><a class="header" href="#思路-15">思路</a></h3>
<ul>
<li>用4颗TreeSet树，一颗维护最小的K个值，一颗维护小的临时值，一颗维护最大的K个值，一颗维护最大的临时K个值。</li>
<li>临时值的两颗树存在的意义：用来存储未过期的值，在对应的小树和大树个树不够的时候补充。</li>
<li>用一个队列维护没有过期的值。</li>
<li>对最小树、最大树和队列操作的同时维护各自的sum。</li>
</ul>
<h3 id="代码-15"><a class="header" href="#代码-15">代码</a></h3>
<pre><code class="language-java">import java.util.*;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/4/11 11:03 上午
 */
public class N4 {
    //[&quot;MKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;]
    //[[3,1],[58916],[61899],[],[85406],[49757],[],[27520],[12303],[],[63945]]
    public static void main(String[] args) {
        MKAverage mkAverage = new MKAverage(3, 1);
        mkAverage.addElement(58916);
        mkAverage.addElement(61899);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(85406);
        mkAverage.addElement(49757);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(27520);
        mkAverage.addElement(12303);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(63945);
    }
}
class MKAverage {

    private final int m;
    private final int k;

    private int sum;
    private int size;

    private Queue&lt;int[]&gt; queue;
    private int minSum;
    private TreeSet&lt;int[]&gt; min;
    private TreeSet&lt;int[]&gt; minT;

    private int maxSum;
    private TreeSet&lt;int[]&gt; max;
    private TreeSet&lt;int[]&gt; maxT;


    public MKAverage(int m, int k) {
        this.m=m;
        this.k=k;
        this.sum=this.maxSum=this.minSum=this.size=0;
        this.queue=new ArrayDeque&lt;&gt;();
        min=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        minT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        max=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
        maxT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
    }

    public void addElement(int num) {
        size++;
        int[] cur = {num, size};
        sum+=num;
        queue.add(cur);
        if(queue.size()&gt;m){
            int[] c = queue.poll();
            sum-=c[0];
            minT.remove(c);
            if(min.remove(c))minSum-=c[0];
            maxT.remove(c);
            if(max.remove(c))maxSum-=c[0];

        }
        minSum+=help(min,minT,cur);
        maxSum+=help(max,maxT,cur);
    }
    private int help(TreeSet&lt;int[]&gt; set,TreeSet&lt;int[]&gt;tSet,int[] cur){
        int res=0;
        while (set.size()&lt;k&amp;&amp;!tSet.isEmpty()){
            int[] c=tSet.pollFirst();
            res+=c[0];
            set.add(c);
        }
        set.add(cur);
        res+=cur[0];
        while (set.size()&gt;k){
            int[] c=set.pollLast();
            res-=c[0];
            tSet.add(c);
        }
        return res;
    }

    public int calculateMKAverage() {
        if(queue.size()&lt;m)return -1;
        //System.out.println(Arrays.toString(new int[]{sum,minSum,maxSum}));
        return (sum-minSum-maxSum)/(m-2*k);
    }
}
/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage obj = new MKAverage(m, k);
 * obj.addElement(num);
 * int param_2 = obj.calculateMKAverage();
 */
/*

</code></pre>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a">题一 <a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></a></h2>
<h3 id="描述-16"><a class="header" href="#描述-16">描述</a></h3>
<p>全字母句 指包含英语字母表中每个字母至少一次的句子。</p>
<p>给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。</p>
<p>如果是，返回 true ；否则，返回 false 。</p>
<p> <!-- more --></p>
<h3 id="思路-16"><a class="header" href="#思路-16">思路</a></h3>
<p>用一个数组记录字母是否出现。</p>
<h3 id="代码-16"><a class="header" href="#代码-16">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public boolean checkIfPangram(String sentence) {
        int[] book=new int[26];
        for (char c:sentence.toCharArray()) book[c-'a']++;
        for (int i:book)if(i==0)return false;
        return true;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a">题二 <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></a></h2>
<h3 id="描述-17"><a class="header" href="#描述-17">描述</a></h3>
<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>
<p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p>
<p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p>
<p>注意：Tony 可以按任意顺序购买雪糕。</p>
<h3 id="思路-17"><a class="header" href="#思路-17">思路</a></h3>
<p>贪心求解即可。</p>
<h3 id="代码-17"><a class="header" href="#代码-17">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res=0;
        for (int cost:costs){
            if(coins&gt;=cost){
                res++;
                coins-=cost;
            }
            else break;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua">题三 <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></a></h2>
<h3 id="描述-18"><a class="header" href="#描述-18">描述</a></h3>
<p>给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。</p>
<p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p>
<p>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。
CPU 可以在完成一项任务后，立即开始执行一项新任务。
返回 CPU 处理任务的顺序。</p>
<h3 id="思路-18"><a class="header" href="#思路-18">思路</a></h3>
<ul>
<li>用优先队列模拟</li>
<li>记录下当前时间</li>
</ul>
<h3 id="代码-18"><a class="header" href="#代码-18">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public int[] getOrder(int[][] tasks) {
        PriorityQueue&lt;int[]&gt; pq=new PriorityQueue&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });

        PriorityQueue&lt;int[]&gt; task=new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[0]));

        for (int i=0;i&lt; tasks.length;i++){
            task.add(new int[]{tasks[i][0],tasks[i][1],i});
        }

        int[] ans=new int[tasks.length];
        int idx=0;
        int cur=0;
        while (!task.isEmpty()||!pq.isEmpty()){
            if(pq.isEmpty()&amp;&amp;cur&lt;task.peek()[0]){
                cur= task.peek()[0];
            }
            while (!task.isEmpty()&amp;&amp;cur&gt;=task.peek()[0]){
                int[] poll = task.poll();
                pq.add(new int[]{poll[1],poll[2]});
            }
            if(!pq.isEmpty()){
                int[] poll = pq.poll();
                ans[idx++]=poll[1];
                cur+=poll[0];
            }
        }

        return ans;

    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a">题四 <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></a></h2>
<h3 id="描述-19"><a class="header" href="#描述-19">描述</a></h3>
<p>列表的 异或和（XOR sum）指对所有元素进行按位 XOR 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。</p>
<p>例如，[1,2,3,4] 的 异或和 等于 1 XOR 2 XOR 3 XOR 4 = 4 ，而 [3] 的 异或和 等于 3 。
给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。</p>
<p>根据每个 (i, j) 数对，构造一个由 arr1[i] AND arr2[j]（按位 AND 运算）结果组成的列表。其中 0 &lt;= i &lt; arr1.length 且 0 &lt;= j &lt; arr2.length 。</p>
<p>返回上述列表的 异或和 。</p>
<h3 id="思路-19"><a class="header" href="#思路-19">思路</a></h3>
<p>找规律，按位数来看，只有当每个数组在当前位为1的个数都是奇数时，最后的结果才会是1。</p>
<h3 id="代码-19"><a class="header" href="#代码-19">代码</a></h3>
<pre><code class="language-java">public class N4 {

    public int getXORSum(int[] arr1, int[] arr2) {
        int[] book1=new int[32];
        int[] book2=new int[32];
        int[] res=new int[32];
        setBook(arr1, book1);
        setBook(arr2,book2);
        for (int i=0;i&lt;32;i++) if(book1[i]%2!=0&amp;&amp;book2[i]%2!=0)res[i]=1;
        int ans=0;
        for (int i=0;i&lt;res.length;i++) if(res[i]==1)ans+=Math.pow(2,i);
        return ans;
    }

    private void setBook(int[] arr, int[] book) {
        for (int num:arr)
        {
            char[] strs = Integer.toBinaryString(num).toCharArray();
            for (int i=0;i&lt;strs.length;i++){
                book[strs.length-i-1]+=strs[i]-'0';
            }
        }
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
