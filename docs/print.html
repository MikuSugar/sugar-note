<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sugar-note</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="algorithm/index.html"><strong aria-hidden="true">1.</strong> 算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/index.html"><strong aria-hidden="true">1.1.</strong> leetcode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第233场周赛.html"><strong aria-hidden="true">1.1.1.</strong> 力扣第233场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第234场周赛.html"><strong aria-hidden="true">1.1.2.</strong> 力扣第234场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第235场周赛.html"><strong aria-hidden="true">1.1.3.</strong> 力扣第235场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第236场周赛.html"><strong aria-hidden="true">1.1.4.</strong> 力扣第236场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第237场周赛.html"><strong aria-hidden="true">1.1.5.</strong> 力扣第237场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第240场周赛.html"><strong aria-hidden="true">1.1.6.</strong> 力扣第240场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第241场周赛.html"><strong aria-hidden="true">1.1.7.</strong> 力扣第241场周赛</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tool/index.html"><strong aria-hidden="true">2.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool/git/index.html"><strong aria-hidden="true">2.1.</strong> git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool/git/gitflow.html"><strong aria-hidden="true">2.1.1.</strong> gitflow</a></li></ol></li><li class="chapter-item expanded "><a href="tool/linux/index.html"><strong aria-hidden="true">2.2.</strong> linux</a></li><li class="chapter-item expanded "><a href="tool/测试硬盘性能.html"><strong aria-hidden="true">2.3.</strong> 测试硬盘性能</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">sugar-note</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sugar-note"><a class="header" href="#sugar-note">Sugar Note</a></h1>
<h2 id="个人笔记库"><a class="header" href="#个人笔记库">个人笔记库～</a></h2>
<p>如有错误,请去这里提交<a href="https://github.com/MikuSugar/sugar-note/issues">issue</a></p>
<p>by mikusugar 2021/05/08</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<p>记录一些算法相关的笔记～</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="leetcode"><a class="header" href="#leetcode">leetcode</a></h1>
<p>记录leetcode相关～</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第233场周赛"><a class="header" href="#力扣第233场周赛">力扣第233场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a">题一 <a href="https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/">最大升序子数组和</a></a></h2>
<h3 id="描述"><a class="header" href="#描述">描述</a></h3>
<p>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。</p>
<p>子数组是数组中的一个连续数字序列。</p>
<p>已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。</p>
<p> <!-- more --></p>
<h3 id="思路"><a class="header" href="#思路">思路</a></h3>
<p>直接遍历求解，遍历时保存上一个值判断是否升序。</p>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public int maxAscendingSum(int[] nums) {
        int res=0;
        int sum=0;
        int pre=0;
        for (int num:nums)
        {
            if(num&gt;pre) sum+=num;
            else sum=num;
            res=Math.max(sum,res);
            pre=num;
        }
        return res;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a">题二 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">积压订单中的订单总数</a></a></h2>
<h3 id="描述-1"><a class="header" href="#描述-1">描述</a></h3>
<p>给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p>
<p>订单类型 orderTypei 可以分为两种：</p>
<p>0 表示这是一批采购订单 buy
1 表示这是一批销售订单 sell
注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p>
<p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p>
<p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 10^9 + 7 取余的结果。</p>
<h3 id="思路-1"><a class="header" href="#思路-1">思路</a></h3>
<p>用两个堆（优先队列）分别存储两种订单，按题目描述模拟即可。</p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<pre><code class="language-java">import java.util.PriorityQueue;

public class N2 {

    private final static int MOD=(int) (1e9+7);

    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue&lt;int[]&gt; sell=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        PriorityQueue&lt;int[]&gt; buy=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o2[1],o1[1]);
            return Integer.compare(o2[0],o1[0]);
        });

        for (int[] order:orders)
        {
            int pricei=order[0];
            int amount=order[1];
            int[] o=sell.poll();
            //buy
            if(order[2]==0)
            {
                while (!sell.isEmpty()&amp;&amp;sell.peek()[0]&lt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount){
                        o[1]-=amount;
                        amount=0;
                        sell.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];

                }
                if(amount&gt;0)buy.add(new int[]{pricei,amount});

            }
            //sell
            else {
                while (!buy.isEmpty()&amp;&amp;buy.peek()[0]&gt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount)
                    {
                        o[1]-=amount;
                        amount=0;
                        buy.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];
                }
                if(amount&gt;0)sell.add(new int[]{pricei,amount});
            }
        }

        long res=0L;
        while (!buy.isEmpty()){
            res+=buy.poll()[1];
            res%=MOD;
        }
        while (!sell.isEmpty()){
            res+=sell.poll()[1];
            res%=MOD;
        }
        return (int) res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a">题三 <a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">有界数组中指定下标处的最大值</a></a></h2>
<h3 id="描述-2"><a class="header" href="#描述-2">描述</a></h3>
<p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p>
<p>nums.length == n
nums[i] 是 正整数 ，其中 0 &lt;= i &lt; n
abs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1
nums 中所有元素之和不超过 maxSum
nums[index] 的值被 最大化
返回你所构造的数组中的 nums[index] 。</p>
<p>注意：abs(x) 等于 x 的前提是 x &gt;= 0 ；否则，abs(x) 等于 -x 。</p>
<h3 id="思路-2"><a class="header" href="#思路-2">思路</a></h3>
<ul>
<li>最大值的情况，从index处递减至1。</li>
<li>二分找出index处最大的值。</li>
</ul>
<h3 id="代码-2"><a class="header" href="#代码-2">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public static void main(String[] args) {
        System.out.println(new N3().maxValue(6, 1, 10));
    }

    public int maxValue(int n, int index, int maxSum) {
        int res=1;
        int left=res, right=maxSum;
        while (left&lt;=right) {
            int mid=(left+right)/2;
            if (check(mid, n, index, maxSum)) {
                res=mid;
                left=mid+1;
            } else right=mid-1;
        }
        return res;
    }

    private boolean check(int max, int n, int index, int maxSum) {
        int sum=0;
        int l=max,lIdx=index;
        while (l&gt;1&amp;&amp;lIdx&gt;=0)
        {
            sum+=l;
            if(sum&gt;maxSum)return false;
            l--;
            lIdx--;
        }
        if(lIdx&gt;=0)sum+=lIdx+1;
        if(sum&gt;maxSum)return false;
        sum-=max;
        int r=max,rIdx=index;
        while (r&gt;1&amp;&amp;rIdx&lt;n){
            sum+=r;
            if(sum&gt;maxSum)return false;
            r--;
            rIdx++;
        }
        if(rIdx!=n)sum+=(n-rIdx);
        // System.out.println(sum);
        return sum&lt;=maxSum;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a">题四 <a href="https://leetcode-cn.com/problems/count-pairs-with-xor-in-a-range/">统计异或值在范围内的数对有多少</a></a></h2>
<h3 id="描述-3"><a class="header" href="#描述-3">描述</a></h3>
<p>给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。</p>
<p>漂亮数对 是一个形如 (i, j) 的数对，其中 0 &lt;= i &lt; j &lt; nums.length 且 low &lt;= (nums[i] XOR nums[j]) &lt;= high 。</p>
<h3 id="思路-3"><a class="header" href="#思路-3">思路</a></h3>
<p>待补充</p>
<h3 id="代码-3"><a class="header" href="#代码-3">代码</a></h3>
<p>待补充</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第234场周赛"><a class="header" href="#力扣第234场周赛">力扣第234场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-234/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></a></h2>
<h3 id="描述-4"><a class="header" href="#描述-4">描述</a></h3>
<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>
<p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123 34 8 34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;</code>、<code>&quot;34&quot;</code>、<code>&quot;8&quot;</code> 和 <code>&quot;34&quot;</code> 。</p>
<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>
<p>如果两个整数的 <strong>不含前导零</strong> 的十进制表示不同，则认为这两个整数也不同。</p>
<p> <!-- more --></p>
<h3 id="思路-4"><a class="header" href="#思路-4">思路</a></h3>
<p>一次遍历，将数字存入Set中，注意前导零。</p>
<h3 id="代码-4"><a class="header" href="#代码-4">代码</a></h3>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Set;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:16 上午
 */
public class N1 {
    public int numDifferentIntegers(String word) {
        int idx=0;
        char[] strs=word.toCharArray();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        while (idx&lt;word.length())
        {
            while (idx&lt;word.length()&amp;&amp;!Character.isDigit(strs[idx]))idx++;
            StringBuilder sb=new StringBuilder();
            while (idx&lt;word.length()&amp;&amp;strs[idx]=='0')idx++;
            while (idx&lt;word.length()&amp;&amp;Character.isDigit(strs[idx]))
            {
                sb.append(strs[idx]);
                idx++;
            }
            if(sb.length()==0&amp;&amp;idx&gt;=1&amp;&amp;strs[idx-1]=='0')sb.append(&quot;0&quot;);
            if(sb.length()!=0)set.add(sb.toString());
        }
        return set.size();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a">题二 <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></a></h2>
<h3 id="描述-5"><a class="header" href="#描述-5">描述</a></h3>
<p>给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。</p>
<p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p>
<p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]
如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]
然后将 arr 赋值给 perm 。</p>
<p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p>
<h3 id="思路-5"><a class="header" href="#思路-5">思路</a></h3>
<p>直接按题目要求模拟。</p>
<h3 id="代码-5"><a class="header" href="#代码-5">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public static void main(String[] args) {
        System.out.println(new N2().reinitializePermutation(4));
    }
    public int reinitializePermutation(int n) {
        int[] arr=new int[n];
        int[] tmp=new int[n];
        for (int i=0;i&lt;n;i++)arr[i]=i;
        for (int res=1;res&lt;4;res++)
        {
            //System.out.println(Arrays.toString(arr));
            for (int i=0;i&lt;n;i++)
            {
                if(i%2==0) tmp[i]=arr[i/2];
                else if(i%2==1) tmp[i]=arr[n/2+(i-1)/2];
            }
            System.arraycopy(tmp, 0, arr, 0, n);
            boolean flag=true;
            for (int i=0;i&lt;n;i++)
            {
                if(arr[i]!=i){
                    flag=false;
                    break;
                }
            }
            if(flag)return res;
        }
        return -1;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a">题三 <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></a></h2>
<h3 id="描述-6"><a class="header" href="#描述-6">描述</a></h3>
<p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p>
<p>比方说，字符串 &quot;(name)is(age)yearsold&quot; 中，有 两个 括号对，分别包含键 &quot;name&quot; 和 &quot;age&quot; 。
你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p>
<p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p>
<p>将 keyi 和括号用对应的值 valuei 替换。
如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 &quot;?&quot; 替换（不需要引号）。
knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p>
<p>请你返回替换 所有 括号对后的结果字符串。</p>
<h3 id="思路-6"><a class="header" href="#思路-6">思路</a></h3>
<ul>
<li>将knowledge变为map方便使用</li>
<li>一次遍历，解析出括号内的key</li>
</ul>
<h3 id="代码-6"><a class="header" href="#代码-6">代码</a></h3>
<pre><code class="language-java">import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:17 上午
 */
public class N3 {

    public String evaluate(String s, List&lt;List&lt;String&gt;&gt; knowledge) {
        Map&lt;String,String&gt; map=new HashMap&lt;&gt;(knowledge.size()*2+5);
        for (List&lt;String&gt; know:knowledge)map.put(know.get(0),know.get(1));
        StringBuilder res=new StringBuilder();
        char[] strs=s.toCharArray();
        int idx=0;
        while (idx&lt;strs.length)
        {
            while (idx&lt;strs.length&amp;&amp;strs[idx]!='(') res.append(strs[idx++]);
            StringBuilder key=new StringBuilder();
            idx++;
            while (idx&lt;strs.length&amp;&amp;strs[idx]!=')') key.append(strs[idx++]);
            idx++;
            if(key.length()&gt;0)res.append(map.getOrDefault(key.toString(),&quot;?&quot;));
        }
        return res.toString();
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a">题四 <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></a></h2>
<h3 id="描述-7"><a class="header" href="#描述-7">描述</a></h3>
<p>给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：</p>
<p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。
n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。
请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。</p>
<p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n 。</p>
<h3 id="思路-7"><a class="header" href="#思路-7">思路</a></h3>
<p>这题一开始想复杂了，总想着把这个正整数找出来。其实这题不需要把这个正整数找出来。</p>
<p>对num进行质因数分解</p>
<pre><code>num=a1^k1*a2^k2.....
</code></pre>
<p>按题目要求可得</p>
<pre><code>k1+k2+.....&lt;=primeFactors
</code></pre>
<p>好因子必须包含有</p>
<pre><code>a1*a2*....
</code></pre>
<p>这个因数。</p>
<p>题目是求好因子数目的最大化的，也就是求</p>
<pre><code>k1*k2*...
</code></pre>
<p>的最大值</p>
<p>如何拆才能尽可能最大，尽可能拆成3。</p>
<p>选择3的理由如下：</p>
<p>依据<strong>均值不等式</strong>可得拆分成想等的值的时候乘积最大。</p>
<p>如果对n进行x份等值拆分可得y=(n/x)^x</p>
<p>可得x=e时，y最大。</p>
<p>最接近e的整数为3。</p>
<h3 id="代码-7"><a class="header" href="#代码-7">代码</a></h3>
<pre><code class="language-java">public class N4 {

    private final static int MOD=(int) (1e9+7);

    public int maxNiceDivisors(int primeFactors) {
        if (primeFactors&lt;=3) return primeFactors;
        if (primeFactors%3==1) return (int) (powMod(3, (primeFactors-4)/3, MOD)*4%MOD);
        if (primeFactors%3==2) return (int) (powMod(3, primeFactors/3, MOD)*2%MOD);
        return (int) (powMod(3, primeFactors/3, MOD));
    }
    //快速幂
    long powMod(long a, long b, final long mod) {
        if (b==0) return 1L;
        long res=powMod(a, b/2, mod)%mod;
        if (b%2==0) return res*res%mod;
        return res*res*a%mod;
    }

}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第235场周赛"><a class="header" href="#力扣第235场周赛">力扣第235场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/truncate-sentence/">截断句子</a></a></h2>
<h3 id="描述-8"><a class="header" href="#描述-8">描述</a></h3>
<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>
<ul>
<li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code> 都是句子。</li>
</ul>
<p>给你一个句子 <code>s</code> 和一个整数 <code>k</code> ，请你将 <code>s</code> <strong>截断</strong> ，使截断后的句子仅含 <strong>前</strong> <code>k</code> 个单词。返回 <strong>截断</strong> <code>s</code>后得到的句子。</p>
<p> <!-- more --></p>
<h3 id="思路-8"><a class="header" href="#思路-8">思路</a></h3>
<ul>
<li>按空格切分句子获得单词</li>
<li>按题目要求拼成截断后的句子</li>
</ul>
<h3 id="代码-8"><a class="header" href="#代码-8">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public String truncateSentence(String s, int k) {
        String[] strs=s.split(&quot; &quot;);
        StringBuilder sb=new StringBuilder();
        for (int i=0;i&lt;k;i++)sb.append(strs[i]).append(&quot; &quot;);
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a">题二 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></a></h2>
<h3 id="描述-9"><a class="header" href="#描述-9">描述</a></h3>
<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p>
<p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>
<p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>
<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>
<p>返回上面描述的答案数组 <code>answer</code> 。</p>
<h3 id="思路-9"><a class="header" href="#思路-9">思路</a></h3>
<p>把日志记录存在</p>
<pre><code class="language-java">Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
</code></pre>
<p>Key 是用户ID，Value存的是活跃时间的集合。</p>
<p>接着遍历map即可得到答案。</p>
<h3 id="代码-9"><a class="header" href="#代码-9">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int[] findingUsersActiveMinutes(int[][] logs, int k) {
        Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
        for (int[] log:logs){
            if(! map.containsKey(log[0]))map.put(log[0],new HashSet&lt;&gt;());
            map.get(log[0]).add(log[1]);
        }
        int[] res=new int[k];
        for (Map.Entry&lt;Integer,Set&lt;Integer&gt;&gt; e:map.entrySet()){
            res[e.getValue().size()-1]++;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a">题三 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/minimum-absolute-sum-difference/">绝对差值和</a></a></h2>
<h3 id="描述-10"><a class="header" href="#描述-10">描述</a></h3>
<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>
<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>
<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>
<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><code>|x|</code> 定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li>
<li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li>
</ul>
<h3 id="思路-10"><a class="header" href="#思路-10">思路</a></h3>
<ul>
<li>先求出绝对差值和。</li>
<li>对每一个位置idx的nums1[idx]尝试替换成最接近nums2[idx]的值</li>
<li>通过二分查找num1中最接近nums2[idx]的值</li>
<li>遍历所有idx</li>
</ul>
<h3 id="代码-10"><a class="header" href="#代码-10">代码</a></h3>
<pre><code class="language-java">public class N3 {

    private final static int MOD=(int) (1e9+7);

    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long sum=0L;
        long min=0L;
        for (int i=0;i&lt;nums1.length;i++)
        {
            sum+=Math.abs(nums1[i]-nums2[i]);
        }
        int[] arr=new int[nums1.length];
        System.arraycopy(nums1, 0, arr, 0, arr.length);
        min=sum;

        Arrays.sort(arr);

        for (int i=0;i&lt;nums1.length;i++)
        {
            int idx=find(nums2[i],arr);
            for (int j=Math.max(0,idx-2);j&lt;=Math.min(idx+2,arr.length-1);j++)
            {
                long tmp=sum-Math.abs(nums1[i]-nums2[i])+Math.abs(arr[j]-nums2[i]);
                min=Math.min(min,tmp);
            }
        }
        return (int) (min%MOD);

    }

    private int find(int tar, int[] arr) {
        if(tar&lt;=arr[0])return 0;
        if(tar&gt;=arr[arr.length-1])return arr.length-1;
        int left=0,right=arr.length-1;
        int res=right;
        while (left&lt;=right){
            int mid=(left+right)/2;
            if(arr[mid]==tar)return mid;
            if(arr[mid]&gt;tar){
                res=mid;
                right=mid-1;
            }
            else left=mid+1;
        }
        return res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a">题四 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></a></h2>
<h3 id="描述-11"><a class="header" href="#描述-11">描述</a></h3>
<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>
<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>
<ul>
<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>
</ul>
<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>
<ul>
<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,**2**,4,1,**5**,**10**]</code> 的一个子序列。</li>
</ul>
<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>
<h3 id="思路-11"><a class="header" href="#思路-11">思路</a></h3>
<ul>
<li>
<p>预计算算出这个范围内数的所有因数</p>
</li>
<li>
<p>如果一个序列中能被K整除有m个，被tk(t&gt;1,且t为整数)整除的数也有m个，那么如果k是一个序列的公约数，tk也是这个序列的公约数。</p>
<p>所以能被K整除个数不等于能被tk整除个数，那么k是一个最大公约数。</p>
</li>
</ul>
<h3 id="代码-11"><a class="header" href="#代码-11">代码</a></h3>
<pre><code class="language-java">public class N4 {
    private final static int MAX=2*100000+1;
    private final static List&lt;Integer&gt;[] factors=new List[MAX];
    private final static int[] book=new int[MAX];
    static{
        //预计算
        for (int i=1;i&lt;MAX;i++)factors[i]=new ArrayList&lt;&gt;();
        for (int i=1;i&lt;MAX;i++){
            for (int j=i;j&lt;MAX;j+=i){
                factors[j].add(i);
            }
        }
    }

    public int countDifferentSubsequenceGCDs(int[] nums) {
        int max=0;
        for (int i:nums)max=Math.max(max,i);
        Arrays.fill(book,0);
        for (int num:nums){
            for (int factor:factors[num]){
                book[factor]++;
            }
        }

        int res=0;
        for (int i=max;i&gt;=1;i--){
            if(book[i]==0)continue;
            boolean flag=true;
            for (int j=i*2;j&lt;=max;j+=i){
                if(book[i]==book[j]){
                    flag=false;
                    break;
                }
            }
            if(flag)res++;
        }
        return res;

    }

}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第236场周赛"><a class="header" href="#力扣第236场周赛">力扣第236场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a">题一 <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></a></h2>
<h3 id="描述-12"><a class="header" href="#描述-12">描述</a></h3>
<p>已知函数 signFunc(x) 将会根据 x 的正负返回特定值：</p>
<p>如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。</p>
<p>返回 signFunc(product) 。</p>
<p> <!-- more --></p>
<h3 id="思路-12"><a class="header" href="#思路-12">思路</a></h3>
<p>本题可以转换成求负数个数。</p>
<h3 id="代码-12"><a class="header" href="#代码-12">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int arraySign(int[] nums) {
        int cnt1=0;
        for (int i:nums)
        {
            if(i==0)return 0;
            if(i&lt;0)cnt1++;
        }
        if(cnt1%2==0)return 1;
        return -1;
    }   
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a">题二 <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></a></h2>
<h3 id="描述-13"><a class="header" href="#描述-13">描述</a></h3>
<p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p>
<p>游戏遵循如下规则：</p>
<p>从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p>
<h3 id="思路-13"><a class="header" href="#思路-13">思路</a></h3>
<ul>
<li>看成队列</li>
<li>模拟游戏规则</li>
</ul>
<h3 id="代码-13"><a class="header" href="#代码-13">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int findTheWinner(int n, int k) {
        Queue&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();
        for (int i=1;i&lt;=n;i++){
            queue.add(i);
        }
        int cur=k;
        while (queue.size()&gt;1){
            cur--;
            int p=queue.poll();
            if(cur!=0)queue.add(p);
            else cur=k;
        }
        return queue.poll();
    }
}
</code></pre>
<h2 id="题三"><a class="header" href="#题三">题三</a></h2>
<h3 id="描述-14"><a class="header" href="#描述-14">描述</a></h3>
<p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p>
<p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p>
<p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>
<p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p>
<p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p>
<h3 id="思路-14"><a class="header" href="#思路-14">思路</a></h3>
<p>动态规划:</p>
<pre><code>dp[number][idx] 表示 在number跑道的idx位置到终点最少还需要几次
</code></pre>
<h3 id="代码-14"><a class="header" href="#代码-14">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int minSideJumps(int[] obstacles) {
        int[][] dp=new int[3][obstacles.length];
        for (int i=0;i&lt;3;i++) Arrays.fill(dp[i],-1);
        int res=slove(2, 0, obstacles, dp);
        return res;
    }

    private int slove(int number, int idx, int[] obstacles, int[][] dp) {
        if(dp[number-1][idx]!=-1)return dp[number-1][idx];
        int res=Integer.MAX_VALUE&gt;&gt;1;
        if(idx==obstacles.length-1)return 0;
        if(obstacles[idx+1]!=number)res=slove(number,idx+1,obstacles,dp);
        else {
            for (int i=1;i&lt;=3;i++)
            {
                if(obstacles[idx]==i||obstacles[idx+1]==i)continue;
                res=Math.min(res,1+slove(i,idx,obstacles,dp));
            }
        }
        return dp[number-1][idx]=res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a">题四 <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></a></h2>
<h3 id="描述-15"><a class="header" href="#描述-15">描述</a></h3>
<p>给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。</p>
<p>MK 平均值 按照如下步骤计算：</p>
<p>如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。
从这个容器中删除最小的 k 个数和最大的 k 个数。
计算剩余元素的平均值，并 向下取整到最近的整数 。
请你实现 MKAverage 类：</p>
<p>MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。
void addElement(int num) 往数据流中插入一个新的元素 num 。
int calculateMKAverage() 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。</p>
<h3 id="思路-15"><a class="header" href="#思路-15">思路</a></h3>
<ul>
<li>用4颗TreeSet树，一颗维护最小的K个值，一颗维护小的临时值，一颗维护最大的K个值，一颗维护最大的临时K个值。</li>
<li>临时值的两颗树存在的意义：用来存储未过期的值，在对应的小树和大树个树不够的时候补充。</li>
<li>用一个队列维护没有过期的值。</li>
<li>对最小树、最大树和队列操作的同时维护各自的sum。</li>
</ul>
<h3 id="代码-15"><a class="header" href="#代码-15">代码</a></h3>
<pre><code class="language-java">import java.util.*;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/4/11 11:03 上午
 */
public class N4 {
    //[&quot;MKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;]
    //[[3,1],[58916],[61899],[],[85406],[49757],[],[27520],[12303],[],[63945]]
    public static void main(String[] args) {
        MKAverage mkAverage = new MKAverage(3, 1);
        mkAverage.addElement(58916);
        mkAverage.addElement(61899);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(85406);
        mkAverage.addElement(49757);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(27520);
        mkAverage.addElement(12303);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(63945);
    }
}
class MKAverage {

    private final int m;
    private final int k;

    private int sum;
    private int size;

    private Queue&lt;int[]&gt; queue;
    private int minSum;
    private TreeSet&lt;int[]&gt; min;
    private TreeSet&lt;int[]&gt; minT;

    private int maxSum;
    private TreeSet&lt;int[]&gt; max;
    private TreeSet&lt;int[]&gt; maxT;


    public MKAverage(int m, int k) {
        this.m=m;
        this.k=k;
        this.sum=this.maxSum=this.minSum=this.size=0;
        this.queue=new ArrayDeque&lt;&gt;();
        min=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        minT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        max=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
        maxT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
    }

    public void addElement(int num) {
        size++;
        int[] cur = {num, size};
        sum+=num;
        queue.add(cur);
        if(queue.size()&gt;m){
            int[] c = queue.poll();
            sum-=c[0];
            minT.remove(c);
            if(min.remove(c))minSum-=c[0];
            maxT.remove(c);
            if(max.remove(c))maxSum-=c[0];

        }
        minSum+=help(min,minT,cur);
        maxSum+=help(max,maxT,cur);
    }
    private int help(TreeSet&lt;int[]&gt; set,TreeSet&lt;int[]&gt;tSet,int[] cur){
        int res=0;
        while (set.size()&lt;k&amp;&amp;!tSet.isEmpty()){
            int[] c=tSet.pollFirst();
            res+=c[0];
            set.add(c);
        }
        set.add(cur);
        res+=cur[0];
        while (set.size()&gt;k){
            int[] c=set.pollLast();
            res-=c[0];
            tSet.add(c);
        }
        return res;
    }

    public int calculateMKAverage() {
        if(queue.size()&lt;m)return -1;
        //System.out.println(Arrays.toString(new int[]{sum,minSum,maxSum}));
        return (sum-minSum-maxSum)/(m-2*k);
    }
}
/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage obj = new MKAverage(m, k);
 * obj.addElement(num);
 * int param_2 = obj.calculateMKAverage();
 */
/*

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第237场周赛"><a class="header" href="#力扣第237场周赛">力扣第237场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a">题一 <a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></a></h2>
<h3 id="描述-16"><a class="header" href="#描述-16">描述</a></h3>
<p>全字母句 指包含英语字母表中每个字母至少一次的句子。</p>
<p>给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。</p>
<p>如果是，返回 true ；否则，返回 false 。</p>
<p> <!-- more --></p>
<h3 id="思路-16"><a class="header" href="#思路-16">思路</a></h3>
<p>用一个数组记录字母是否出现。</p>
<h3 id="代码-16"><a class="header" href="#代码-16">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public boolean checkIfPangram(String sentence) {
        int[] book=new int[26];
        for (char c:sentence.toCharArray()) book[c-'a']++;
        for (int i:book)if(i==0)return false;
        return true;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a">题二 <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></a></h2>
<h3 id="描述-17"><a class="header" href="#描述-17">描述</a></h3>
<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>
<p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p>
<p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p>
<p>注意：Tony 可以按任意顺序购买雪糕。</p>
<h3 id="思路-17"><a class="header" href="#思路-17">思路</a></h3>
<p>贪心求解即可。</p>
<h3 id="代码-17"><a class="header" href="#代码-17">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res=0;
        for (int cost:costs){
            if(coins&gt;=cost){
                res++;
                coins-=cost;
            }
            else break;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua">题三 <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></a></h2>
<h3 id="描述-18"><a class="header" href="#描述-18">描述</a></h3>
<p>给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。</p>
<p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p>
<p>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。
CPU 可以在完成一项任务后，立即开始执行一项新任务。
返回 CPU 处理任务的顺序。</p>
<h3 id="思路-18"><a class="header" href="#思路-18">思路</a></h3>
<ul>
<li>用优先队列模拟</li>
<li>记录下当前时间</li>
</ul>
<h3 id="代码-18"><a class="header" href="#代码-18">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public int[] getOrder(int[][] tasks) {
        PriorityQueue&lt;int[]&gt; pq=new PriorityQueue&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });

        PriorityQueue&lt;int[]&gt; task=new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[0]));

        for (int i=0;i&lt; tasks.length;i++){
            task.add(new int[]{tasks[i][0],tasks[i][1],i});
        }

        int[] ans=new int[tasks.length];
        int idx=0;
        int cur=0;
        while (!task.isEmpty()||!pq.isEmpty()){
            if(pq.isEmpty()&amp;&amp;cur&lt;task.peek()[0]){
                cur= task.peek()[0];
            }
            while (!task.isEmpty()&amp;&amp;cur&gt;=task.peek()[0]){
                int[] poll = task.poll();
                pq.add(new int[]{poll[1],poll[2]});
            }
            if(!pq.isEmpty()){
                int[] poll = pq.poll();
                ans[idx++]=poll[1];
                cur+=poll[0];
            }
        }

        return ans;

    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a">题四 <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></a></h2>
<h3 id="描述-19"><a class="header" href="#描述-19">描述</a></h3>
<p>列表的 异或和（XOR sum）指对所有元素进行按位 XOR 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。</p>
<p>例如，[1,2,3,4] 的 异或和 等于 1 XOR 2 XOR 3 XOR 4 = 4 ，而 [3] 的 异或和 等于 3 。
给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。</p>
<p>根据每个 (i, j) 数对，构造一个由 arr1[i] AND arr2[j]（按位 AND 运算）结果组成的列表。其中 0 &lt;= i &lt; arr1.length 且 0 &lt;= j &lt; arr2.length 。</p>
<p>返回上述列表的 异或和 。</p>
<h3 id="思路-19"><a class="header" href="#思路-19">思路</a></h3>
<p>找规律，按位数来看，只有当每个数组在当前位为1的个数都是奇数时，最后的结果才会是1。</p>
<h3 id="代码-19"><a class="header" href="#代码-19">代码</a></h3>
<pre><code class="language-java">public class N4 {

    public int getXORSum(int[] arr1, int[] arr2) {
        int[] book1=new int[32];
        int[] book2=new int[32];
        int[] res=new int[32];
        setBook(arr1, book1);
        setBook(arr2,book2);
        for (int i=0;i&lt;32;i++) if(book1[i]%2!=0&amp;&amp;book2[i]%2!=0)res[i]=1;
        int ans=0;
        for (int i=0;i&lt;res.length;i++) if(res[i]==1)ans+=Math.pow(2,i);
        return ans;
    }

    private void setBook(int[] arr, int[] book) {
        for (int num:arr)
        {
            char[] strs = Integer.toBinaryString(num).toCharArray();
            for (int i=0;i&lt;strs.length;i++){
                book[strs.length-i-1]+=strs[i]-'0';
            }
        }
    }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第240场周赛"><a class="header" href="#力扣第240场周赛">力扣第240场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsmaximum-population-year人口最多的年份a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsmaximum-population-year人口最多的年份a">题一 <a href="https://leetcode-cn.com/problems/maximum-population-year/">人口最多的年份</a></a></h2>
<h3 id="描述-20"><a class="header" href="#描述-20">描述</a></h3>
<p>给你一个二维整数数组 logs ，其中每个 logs[i] = [birthi, deathi] 表示第 i 个人的出生和死亡年份。</p>
<p>年份 x 的 人口 定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：x 在闭区间 [birthi, deathi - 1] 内。注意，人不应当计入他们死亡当年的人口中。</p>
<p>返回 人口最多 且 最早 的年份。</p>
<p>示例 1：</p>
<p>输入：logs = [[1993,1999],[2000,2010]]
输出：1993
解释：人口最多为 1 ，而 1993 是人口为 1 的最早年份。
示例 2：</p>
<p>输入：logs = [[1950,1961],[1960,1971],[1970,1981]]
输出：1960
解释：
人口最多为 2 ，分别出现在 1960 和 1970 。
其中最早年份是 1960 。</p>
<p>提示：</p>
<p>1 &lt;= logs.length &lt;= 100
1950 &lt;= birthi &lt; deathi &lt;= 2050</p>
<h3 id="思路-20"><a class="header" href="#思路-20">思路</a></h3>
<p>用一个数组存储所有年份出生的人数减去去世的人数，然后遍历得到人口最多的年份。</p>
<h3 id="代码-20"><a class="header" href="#代码-20">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

public class N1 {
    public int maximumPopulation(int[][] logs) {
        int[] book=new int[101];
        for (int[] log:logs){
            book[log[0]-1950]++;
            book[log[1]-1950]--;
        }
        int s=0;
        int max=0;
        int res=1950;
        for (int i=0;i&lt; book.length;i++){
            s+=book[i];
            if(max&lt;s){
                max=s;
                res=i+1950;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-distance-between-a-pair-of-values下标对中的最大距离a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-distance-between-a-pair-of-values下标对中的最大距离a">题二 <a href="https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/">下标对中的最大距离</a></a></h2>
<h3 id="描述-21"><a class="header" href="#描述-21">描述</a></h3>
<p>给你两个 非递增 的整数数组 nums1 和 nums2 ，数组下标均 从 0 开始 计数。</p>
<p>下标对 (i, j) 中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length 。如果该下标对同时满足 i &lt;= j 且 nums1[i] &lt;= nums2[j] ，则称之为 有效 下标对，该下标对的 距离 为 j - i 。</p>
<p>返回所有 有效 下标对 (i, j) 中的 最大距离 。如果不存在有效下标对，返回 0 。</p>
<p>一个数组 arr ，如果每个 1 &lt;= i &lt; arr.length 均有 arr[i-1] &gt;= arr[i] 成立，那么该数组是一个 非递增 数组。</p>
<p>示例 1：</p>
<p>输入：nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
输出：2
解释：有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。
最大距离是 2 ，对应下标对 (2,4) 。
示例 2：</p>
<p>输入：nums1 = [2,2,2], nums2 = [10,10,1]
输出：1
解释：有效下标对是 (0,0), (0,1) 和 (1,1) 。
最大距离是 1 ，对应下标对 (0,1) 。
示例 3：</p>
<p>输入：nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
输出：2
解释：有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。
最大距离是 2 ，对应下标对 (2,4) 。
示例 4：</p>
<p>输入：nums1 = [5,4], nums2 = [3,2]
输出：0
解释：不存在有效下标对，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 10^5
1 &lt;= nums2.length &lt;= 10^5
1 &lt;= nums1[i], nums2[j] &lt;= 10^5
nums1 和 nums2 都是 非递增 数组</p>
<h3 id="思路-21"><a class="header" href="#思路-21">思路</a></h3>
<p>二分查找。</p>
<h3 id="代码-21"><a class="header" href="#代码-21">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

public class N2 {
    public int maxDistance(int[] nums1, int[] nums2) {
        int res=0;
        for (int i=0;i&lt;nums1.length;i++){
            if(i&gt;=nums2.length)break;
            int j=find(nums2,i,nums1[i]);
            if(j!=-1){
                res=Math.max(j-i,res);
            }
        }
        return res;
    }

    private int find(int[] nums, int i, int tar) {
        if(nums[i]&lt;tar)return -1;
        int l=i,r=nums.length-1;
        int res=i;
        while (l&lt;=r){
            int mid=(l+r)/2;
            if(nums[mid]&gt;=tar){
                res=Math.max(res,mid);
                l=mid+1;
            }
            else r=mid-1;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三--a-hrefhttpsleetcode-cncomproblemsmaximum-subarray-min-product子数组最小乘积的最大值a"><a class="header" href="#题三--a-hrefhttpsleetcode-cncomproblemsmaximum-subarray-min-product子数组最小乘积的最大值a">题三  <a href="https://leetcode-cn.com/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></a></h2>
<h3 id="描述-22"><a class="header" href="#描述-22">描述</a></h3>
<p>一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。</p>
<p>比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。
给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。</p>
<p>请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。</p>
<p>子数组 定义为一个数组的 连续 部分。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,2]
输出：14
解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
2 * (2+3+2) = 2 * 7 = 14 。
示例 2：</p>
<p>输入：nums = [2,3,3,1,2]
输出：18
解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。
3 * (3+3) = 3 * 6 = 18 。
示例 3：</p>
<p>输入：nums = [3,1,5,6,4,2]
输出：60
解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。
4 * (5+6+4) = 4 * 15 = 60 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^7</p>
<h3 id="思路-22"><a class="header" href="#思路-22">思路</a></h3>
<ul>
<li>
<p>预处理sum。</p>
</li>
<li>
<p>依次遍历，假定当前值就是序列中的最小值，通过单调栈找到另一个边界计算即可。</p>
</li>
</ul>
<h3 id="代码-22"><a class="header" href="#代码-22">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

import java.util.Stack;

public class N3 {
    public int maxSumMinProduct(int[] nums) {
        final int MOD= (int) (Math.pow(10,9)+7);
        long[] sum=new long[nums.length+1];
        for (int i=1;i&lt;=nums.length;i++){
            sum[i]=sum[i-1]+nums[i-1];
        }
        long res=0;
        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();
        for (int i=0;i&lt;nums.length;i++){
            while (!stack.isEmpty()&amp;&amp;nums[i]&lt;=nums[stack.peek()]){
                int peek=stack.pop();
                int l=stack.isEmpty()?-1:stack.peek();
                res=Math.max(res, nums[peek] * (sum[i] - sum[l + 1]));
            }
            stack.push(i);
        }
        while (!stack.isEmpty()){
            int peek=stack.pop();
            int l=stack.isEmpty()?-1:stack.peek();
            res=Math.max(res, (sum[nums.length] - sum[l + 1]) *nums[peek]);
        }
        return (int) (res%MOD);
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemslargest-color-value-in-a-directed-graph有向图中最大颜色值a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemslargest-color-value-in-a-directed-graph有向图中最大颜色值a">题四 <a href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/">有向图中最大颜色值</a></a></h2>
<h3 id="描述-23"><a class="header" href="#描述-23">描述</a></h3>
<p>给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。</p>
<p>给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。</p>
<p>图中一条有效 路径 是一个点序列 x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk ，对于所有 1 &lt;= i &lt; k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。</p>
<p>请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。</p>
<p>示例 1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/6ddJXu.jpg" alt="6ddJXu" /></p>
<p>输入：colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
输出：3
解释：路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 &quot;a&quot; 的节点（上图中的红色节点）。
示例 2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/4IMrd2.jpg" alt="4IMrd2" /></p>
<p>输入：colors = &quot;a&quot;, edges = [[0,0]]
输出：-1
解释：从 0 到 0 有一个环。</p>
<p>提示：</p>
<p>n == colors.length
m == edges.length
1 &lt;= n &lt;= 105
0 &lt;= m &lt;= 105
colors 只含有小写英文字母。
0 &lt;= aj, bj &lt; n</p>
<h3 id="思路-23"><a class="header" href="#思路-23">思路</a></h3>
<p>没有</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<h3 id="代码-23"><a class="header" href="#代码-23">代码</a></h3>
<p>没有</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="力扣第241场周赛"><a class="header" href="#力扣第241场周赛">力扣第241场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemssum-of-all-subset-xor-totals找出所有子集的异或总和再求和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemssum-of-all-subset-xor-totals找出所有子集的异或总和再求和a">题一 <a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/">找出所有子集的异或总和再求和</a></a></h2>
<h3 id="描述-24"><a class="header" href="#描述-24">描述</a></h3>
<p>一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。</p>
<p>例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。
给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p>
<p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p>
<p>数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3]
输出：6
解释：[1,3] 共有 4 个子集：</p>
<ul>
<li>空子集的异或总和是 0 。</li>
<li>[1] 的异或总和为 1 。</li>
<li>[3] 的异或总和为 3 。</li>
<li>[1,3] 的异或总和为 1 XOR 3 = 2 。
0 + 1 + 3 + 2 = 6
示例 2：</li>
</ul>
<p>输入：nums = [5,1,6]
输出：28
解释：[5,1,6] 共有 8 个子集：</p>
<ul>
<li>空子集的异或总和是 0 。</li>
<li>[5] 的异或总和为 5 。</li>
<li>[1] 的异或总和为 1 。</li>
<li>[6] 的异或总和为 6 。</li>
<li>[5,1] 的异或总和为 5 XOR 1 = 4 。</li>
<li>[5,6] 的异或总和为 5 XOR 6 = 3 。</li>
<li>[1,6] 的异或总和为 1 XOR 6 = 7 。</li>
<li>[5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
示例 3：</li>
</ul>
<p>输入：nums = [3,4,5,6,7,8]
输出：480
解释：每个子集的全部异或总和值之和为 480 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 12
1 &lt;= nums[i] &lt;= 20</p>
<h3 id="思路-24"><a class="header" href="#思路-24">思路</a></h3>
<p>DFS 遍历所有可能。</p>
<h3 id="代码-24"><a class="header" href="#代码-24">代码</a></h3>
<pre><code class="language-java">public class N1 {
    private int sum;
    public int subsetXORSum(int[] nums) {
        sum=0;
        dfs(0,nums,0);
        return sum;
    }

    private void dfs(int pre, int[] nums, int idx) {
        if(idx&gt;= nums.length)return;
        final int next = pre ^ nums[idx];
        sum+=next;
        dfs(next,nums,idx+1);
        dfs(pre,nums,idx+1);
    }

}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-binary-string-alternating构成交替字符串需要的最小交换次数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-binary-string-alternating构成交替字符串需要的最小交换次数a">题二 <a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/">构成交替字符串需要的最小交换次数</a></a></h2>
<h3 id="描述-25"><a class="header" href="#描述-25">描述</a></h3>
<p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p>
<p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 &quot;010&quot; 和 &quot;1010&quot; 属于交替字符串，但 &quot;0100&quot; 不是。</p>
<p>任意两个字符都可以进行交换，不必相邻 。</p>
<p>示例 1：</p>
<p>输入：s = &quot;111000&quot;
输出：1
解释：交换位置 1 和 4：&quot;111000&quot; -&gt; &quot;101010&quot; ，字符串变为交替字符串。
示例 2：</p>
<p>输入：s = &quot;010&quot;
输出：0
解释：字符串已经是交替字符串了，不需要交换。
示例 3：</p>
<p>输入：s = &quot;1110&quot;
输出：-1</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000
s[i] 的值为 '0' 或 '1'</p>
<h3 id="思路-25"><a class="header" href="#思路-25">思路</a></h3>
<ul>
<li>统计出1和0的个数</li>
<li>如果1和0的个数差距大于1 则无法构成交替字符串</li>
<li>如果1和0的个数相等：
<ul>
<li>统计偶数位是1需要交替的次数。</li>
<li>统计偶数位是0需要交替的次数。</li>
<li>取上面的最小值。</li>
</ul>
</li>
<li>如果1的个数大于0的个数，则说明偶数位一定是1</li>
<li>如果1的个数小于0的个数，则说明偶数位一定是0。</li>
</ul>
<h3 id="代码-25"><a class="header" href="#代码-25">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public static void main(String[] args) {
        System.out.println(new N2().minSwaps(&quot;00011110110110000000000110110101011101111011111101010010010000000000000001101101010010001011110000001101111111110000110101101101001011000011111011101101100110011111110001100110001110000000001100010111110100111001001111100001000110101111010011001&quot;));
    }
    public int minSwaps(String s) {
        final char[] strs = s.toCharArray();
        int cnt0,cnt1;
        cnt0=cnt1=0;
        for (char c:strs){
            if(c=='0')cnt0++;
            else cnt1++;
        }
        if(Math.abs(cnt0-cnt1)!=1&amp;&amp;cnt0!=cnt1)return -1;
        int res=0;
        if(cnt0&gt;cnt1){
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='1')res++;
            }
        }
        else if(cnt0==cnt1){
            int res1=0;
            int res2=0;
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='0')res1++;
                else res2++;
            }
            res=Math.min(res1,res2);
        }
        else {
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='0')res++;
            }
        }
        return res;

    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsfinding-pairs-with-a-certain-sum找出和为指定值的下标对a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsfinding-pairs-with-a-certain-sum找出和为指定值的下标对a">题三 <a href="https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum/">找出和为指定值的下标对</a></a></h2>
<h3 id="描述-26"><a class="header" href="#描述-26">描述</a></h3>
<p>给你两个整数数组 nums1 和 nums2 ，请你实现一个支持下述两类查询的数据结构：</p>
<p>累加 ，将一个正整数加到 nums2 中指定下标对应元素上。
计数 ，统计满足 nums1[i] + nums2[j] 等于指定值的下标对 (i, j) 数目（0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length）。
实现 FindSumPairs 类：</p>
<p>FindSumPairs(int[] nums1, int[] nums2) 使用整数数组 nums1 和 nums2 初始化 FindSumPairs 对象。
void add(int index, int val) 将 val 加到 nums2[index] 上，即，执行 nums2[index] += val 。
int count(int tot) 返回满足 nums1[i] + nums2[j] == tot 的下标对 (i, j) 数目。</p>
<p>示例：</p>
<p>输入：
[&quot;FindSumPairs&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;]
[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
输出：
[null, 8, null, 2, 1, null, null, 11]</p>
<p>解释：
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7
findSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8
findSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4
findSumPairs.add(0, 1); // 此时 nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // 此时 nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7</p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 1000
1 &lt;= nums2.length &lt;= 10^5
1 &lt;= nums1[i] &lt;= 10^9
1 &lt;= nums2[i] &lt;= 10^5
0 &lt;= index &lt; nums2.length
1 &lt;= val &lt;= 10^5
1 &lt;= tot &lt;= 10^9
最多调用 add 和 count 函数各 1000 次</p>
<h3 id="思路-26"><a class="header" href="#思路-26">思路</a></h3>
<ul>
<li>将数据分别额外存储在两个Map中。key是值，value是个数</li>
<li>add操作的同时更新map2相关KV对</li>
<li>求count的是遍历size小的map找出对应map的value，对数相当于两个value相乘。</li>
</ul>
<h3 id="代码-26"><a class="header" href="#代码-26">代码</a></h3>
<pre><code class="language-java">class FindSumPairs {

    private int[] nums2;
    private Map&lt;Integer,Integer&gt; map1;
    private Map&lt;Integer,Integer&gt; map2;
    public FindSumPairs(int[] nums1, int[] nums2) {
        this.nums2=nums2;
        map1=new HashMap&lt;&gt;();
        map2=new HashMap&lt;&gt;();
        for (int i:nums1)map1.put(i,map1.getOrDefault(i,0)+1);
        for (int i:nums2)map2.put(i,map2.getOrDefault(i,0)+1);
    }

    public void add(int index, int val) {
        final int cnt = map2.getOrDefault(nums2[index], 0) - 1;
        if(cnt==0)map2.remove(nums2[index]);
        else map2.put(nums2[index],cnt);
        nums2[index]+=val;
        map2.put(nums2[index],map2.getOrDefault(nums2[index],0)+1);
    }

    public int count(int tot) {
        Map&lt;Integer,Integer&gt; m1;
        Map&lt;Integer,Integer&gt; m2;
        if(map1.size()&lt;=map2.size()){
            m1=map1;
            m2=map2;
        }else {
            m1=map2;
            m2=map1;
        }
        int res=0;
        for (Map.Entry&lt;Integer,Integer&gt; e:m1.entrySet()){
            res+=e.getValue()*m2.getOrDefault(tot-e.getKey(),0);
        }
        return res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsnumber-of-ways-to-rearrange-sticks-with-k-sticks-visible恰有-k-根木棍可以看到的排列数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsnumber-of-ways-to-rearrange-sticks-with-k-sticks-visible恰有-k-根木棍可以看到的排列数目a">题四 <a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/">恰有 K 根木棍可以看到的排列数目</a></a></h2>
<h3 id="描述-27"><a class="header" href="#描述-27">描述</a></h3>
<p>有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。</p>
<p>例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。
给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。</p>
<p>示例 1：</p>
<p>输入：n = 3, k = 2
输出：3
解释：[1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
示例 2：</p>
<p>输入：n = 5, k = 5
输出：1
解释：[1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
示例 3：</p>
<p>输入：n = 20, k = 11
输出：647427950
解释：总共有 647427950 (mod 109 + 7) 种能满足恰好有 11 根木棍可以看到的排列。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 1000
1 &lt;= k &lt;= n</p>
<h3 id="思路-27"><a class="header" href="#思路-27">思路</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<h3 id="代码-27"><a class="header" href="#代码-27">代码</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="工具"><a class="header" href="#工具">工具</a></h1>
<p>一些日常工具使用笔记～</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">git</a></h1>
<p>关于git的一些笔记～</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="git-flow"><a class="header" href="#git-flow">git flow</a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code class="language-bash">brew install git-flow-avh
</code></pre>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/OZH3W0.jpg" alt="命令" /></p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<pre><code class="language-bash">git flow init 
</code></pre>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<h4 id="增加新特性"><a class="header" href="#增加新特性">增加新特性</a></h4>
<p>新特性的开发是基于 'develop' 分支的。</p>
<p>通过下面的命令开始开发新特性：</p>
<pre><code class="language-bash">git flow feature start MYFEATURE
</code></pre>
<p>这个操作创建了一个基于'develop'的特性分支，并切换到这个分支之下。</p>
<h4 id="完成新特性"><a class="header" href="#完成新特性">完成新特性</a></h4>
<p>完成开发新特性。这个动作执行下面的操作.</p>
<ul>
<li>合并 MYFEATURE 分支到 'develop'</li>
<li>删除这个新特性分支</li>
<li>切换回 'develop' 分支</li>
</ul>
<pre><code class="language-bash">git flow feature finish MYFEATURE
</code></pre>
<h4 id="发布新特性"><a class="header" href="#发布新特性">发布新特性</a></h4>
<p>发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。</p>
<pre><code class="language-bash">git flow feature publish MYFEATURE
</code></pre>
<h4 id="取得一个发布的新特性分支"><a class="header" href="#取得一个发布的新特性分支">取得一个发布的新特性分支</a></h4>
<p>取得其它用户发布的新特性分支，并签出远程的变更。</p>
<pre><code class="language-bash">git flow feature pull origin MYFEATURE
</code></pre>
<p>使用下列命令追踪origin上的特性分支</p>
<pre><code class="language-bash">git flow feature track MYFEATURE
</code></pre>
<h3 id="release"><a class="header" href="#release">release</a></h3>
<h4 id="准备release"><a class="header" href="#准备release">准备release</a></h4>
<p>它从 'develop' 分支开始创建一个 release 分支。</p>
<pre><code class="language-bash">git flow release start RELEASE [BASE]
</code></pre>
<p>你可以选择提供一个 <code>[BASE]</code>参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是'develop' 分支下的。</p>
<h4 id="发布release"><a class="header" href="#发布release">发布release</a></h4>
<pre><code class="language-bash">git flow release publish RELEASE
</code></pre>
<p>通过以下命令签出release版本的远程变更</p>
<pre><code class="language-bash">git flow release track RELEASE
</code></pre>
<h4 id="完成release"><a class="header" href="#完成release">完成release</a></h4>
<p>完成 release 版本是一个大 git 分支操作。它执行下面几个动作：</p>
<ul>
<li>归并 release 分支到 'master' 分支</li>
<li>用 release 分支名打 Tag</li>
<li>归并 release 分支到 'develop'</li>
<li>移除 release 分支</li>
</ul>
<pre><code class="language-bash">git flow release finish RELEASE
</code></pre>
<h3 id="紧急修复"><a class="header" href="#紧急修复">紧急修复</a></h3>
<h4 id="开始紧急修复"><a class="header" href="#开始紧急修复">开始紧急修复</a></h4>
<pre><code class="language-bash">git flow hotfix start VERSION [BASENAME]
</code></pre>
<p>VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，<code>[BASENAME]</code>为finish release时填写的版本号</p>
<h4 id="完成紧急修复"><a class="header" href="#完成紧急修复">完成紧急修复</a></h4>
<p>当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p>
<pre><code class="language-bash">git flow hotfix finish VERSION
</code></pre>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p>http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">linux</a></h1>
<p>记录Linux相关。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="测试硬盘性能"><a class="header" href="#测试硬盘性能">测试硬盘性能</a></h1>
<h2 id="linux上测试"><a class="header" href="#linux上测试">Linux上测试</a></h2>
<p>使用<code>dd</code> 命令简单测试硬盘</p>
<pre><code class="language-shell">dd if=/dev/zero of=/data/disk1/tmp/test1.img bs=1G count=1 oflag=dsync
</code></pre>
<p>参数解释 </p>
<ul>
<li><code>if=/dev/zero</code> (if=/dev/input.file) ：用来设置dd命令读取的输入文件名。</li>
<li><code>of=/data/disk1/tmp/test1.img</code> (of=/path/to/output.file)：dd命令将input.file写入的输出文件的名字。</li>
<li><code>bs=1G</code> (bs=block-size) ：设置dd命令读取的块的大小。例子中为1个G;bs选项的默认单位是bytes</li>
<li><code>count=1</code> (count=number-of-blocks)：dd命令读取的块的个数。</li>
<li><code>oflag=dsync</code> (oflag=dsync) ：使用同步I/O。不要省略这个选项。这个选项能够帮助你去除caching的影响，以便呈现给你精准的结果。</li>
<li><code>conv=fdatasyn</code>: 这个选项和<code>oflag=dsync</code>含义一样。</li>
</ul>
<p>普通HDD写速度:</p>
<table><thead><tr><th>文件信息</th><th>速度</th></tr></thead><tbody>
<tr><td>1G</td><td>134MB/S</td></tr>
<tr><td>512bytes*1000</td><td>265KB/s</td></tr>
<tr><td>4k*1000</td><td>2.1MB/s</td></tr>
<tr><td>8k*1000</td><td>4.2MB/S</td></tr>
</tbody></table>
<p>AWS EBS写速度（t3.micro）:</p>
<table><thead><tr><th>文件信息</th><th>速度</th></tr></thead><tbody>
<tr><td>300MB</td><td>219MB/S</td></tr>
<tr><td>512bytes*1000</td><td>382kb/s</td></tr>
<tr><td>4k*1000</td><td>3.3MB/S</td></tr>
<tr><td>8k*1000</td><td>6.7MB/S</td></tr>
</tbody></table>
<h2 id="mac-上测试"><a class="header" href="#mac-上测试">Mac 上测试</a></h2>
<p>Mac 上的dd命令 单位是小写，如GB位g，MB位m。</p>
<p>例子：</p>
<pre><code class="language-shell">dd if=/dev/zero of=test1.img bs=1g count=1  2&gt;&amp;1 | grep sec | awk '{print $1 / 1024 / 1024 / $5, &quot;MB/sec&quot; }'
</code></pre>
<p>SSD写速度</p>
<table><thead><tr><th>文件信息</th><th>速度</th></tr></thead><tbody>
<tr><td>1G</td><td>2361.93 MB/s</td></tr>
<tr><td>512bytes*1000</td><td>20MB/s</td></tr>
<tr><td>4k*1000</td><td>823.93Mb/s</td></tr>
<tr><td>8k*1000</td><td>1505.88Mb/s</td></tr>
</tbody></table>

                    </main>


                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
                <div id="disqus_thread"></div>
                <script>
                    /**
                     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
                    /*
                    var disqus_config = function () {
                    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                    };
                    */
                    (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');
                        s.src = 'https://mikusugar-me.disqus.com/embed.js';
                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
