<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sugar-note</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="mikusugar的笔记整理">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="algorithm/index.html"><strong aria-hidden="true">1.</strong> 算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/index.html"><strong aria-hidden="true">1.1.</strong> leetcode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第233场周赛.html"><strong aria-hidden="true">1.1.1.</strong> 力扣第233场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第234场周赛.html"><strong aria-hidden="true">1.1.2.</strong> 力扣第234场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第235场周赛.html"><strong aria-hidden="true">1.1.3.</strong> 力扣第235场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第236场周赛.html"><strong aria-hidden="true">1.1.4.</strong> 力扣第236场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第237场周赛.html"><strong aria-hidden="true">1.1.5.</strong> 力扣第237场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第240场周赛.html"><strong aria-hidden="true">1.1.6.</strong> 力扣第240场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第241场周赛.html"><strong aria-hidden="true">1.1.7.</strong> 力扣第241场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第243场周赛.html"><strong aria-hidden="true">1.1.8.</strong> 力扣第243场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第244场周赛.html"><strong aria-hidden="true">1.1.9.</strong> 力扣第244场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第252场周赛.html"><strong aria-hidden="true">1.1.10.</strong> 力扣第252场周赛</a></li><li class="chapter-item expanded "><a href="algorithm/leetcode/力扣第253场周赛.html"><strong aria-hidden="true">1.1.11.</strong> 力扣第253场周赛</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tool/index.html"><strong aria-hidden="true">2.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool/git/index.html"><strong aria-hidden="true">2.1.</strong> git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tool/git/gitflow.html"><strong aria-hidden="true">2.1.1.</strong> gitflow</a></li></ol></li><li class="chapter-item expanded "><a href="tool/linux/index.html"><strong aria-hidden="true">2.2.</strong> linux</a></li><li class="chapter-item expanded "><a href="tool/测试硬盘性能.html"><strong aria-hidden="true">2.3.</strong> 测试硬盘性能</a></li></ol></li><li class="chapter-item expanded "><a href="bigdata/index.html"><strong aria-hidden="true">3.</strong> 大数据</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bigdata/hive_metastore_java_api.html"><strong aria-hidden="true">3.1.</strong> hive metastore java api</a></li><li class="chapter-item expanded "><a href="bigdata/flink/index.html"><strong aria-hidden="true">3.2.</strong> Flink</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bigdata/flink/Flink任务提交入口.html"><strong aria-hidden="true">3.2.1.</strong> Flink任务提交入口</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">sugar-note</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sugar-note"><a class="header" href="#sugar-note">Sugar Note</a></h1>
<h2 id="个人笔记库"><a class="header" href="#个人笔记库">个人笔记库～</a></h2>
<p>如有错误,请去这里提交<a href="https://github.com/MikuSugar/sugar-note/issues">issue</a></p>
<p>by mikusugar 2021/05/08</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<p>记录一些算法相关的笔记～</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leetcode"><a class="header" href="#leetcode">leetcode</a></h1>
<p>记录leetcode相关～</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第233场周赛"><a class="header" href="#力扣第233场周赛">力扣第233场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsmaximum-ascending-subarray-sum最大升序子数组和a">题一 <a href="https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/">最大升序子数组和</a></a></h2>
<h3 id="描述"><a class="header" href="#描述">描述</a></h3>
<p>给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。</p>
<p>子数组是数组中的一个连续数字序列。</p>
<p>已知子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，若对所有 i（l &lt;= i &lt; r），numsi &lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。</p>
<p> <!-- more --></p>
<h3 id="思路"><a class="header" href="#思路">思路</a></h3>
<p>直接遍历求解，遍历时保存上一个值判断是否升序。</p>
<h3 id="代码"><a class="header" href="#代码">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public int maxAscendingSum(int[] nums) {
        int res=0;
        int sum=0;
        int pre=0;
        for (int num:nums)
        {
            if(num&gt;pre) sum+=num;
            else sum=num;
            res=Math.max(sum,res);
            pre=num;
        }
        return res;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsnumber-of-orders-in-the-backlog积压订单中的订单总数a">题二 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/">积压订单中的订单总数</a></a></h2>
<h3 id="描述-1"><a class="header" href="#描述-1">描述</a></h3>
<p>给你一个二维整数数组 orders ，其中每个 orders[i] = [pricei, amounti, orderTypei] 表示有 amounti 笔类型为 orderTypei 、价格为 pricei 的订单。</p>
<p>订单类型 orderTypei 可以分为两种：</p>
<p>0 表示这是一批采购订单 buy
1 表示这是一批销售订单 sell
注意，orders[i] 表示一批共计 amounti 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 i ，由 orders[i] 表示的所有订单提交时间均早于 orders[i+1] 表示的所有订单。</p>
<p>存在由未执行订单组成的 积压订单 。积压订单最初是空的。提交订单时，会发生以下情况：</p>
<p>如果该订单是一笔采购订单 buy ，则可以查看积压订单中价格 最低 的销售订单 sell 。如果该销售订单 sell 的价格 低于或等于 当前采购订单 buy 的价格，则匹配并执行这两笔订单，并将销售订单 sell 从积压订单中删除。否则，采购订单 buy 将会添加到积压订单中。
反之亦然，如果该订单是一笔销售订单 sell ，则可以查看积压订单中价格 最高 的采购订单 buy 。如果该采购订单 buy 的价格 高于或等于 当前销售订单 sell 的价格，则匹配并执行这两笔订单，并将采购订单 buy 从积压订单中删除。否则，销售订单 sell 将会添加到积压订单中。
输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 10^9 + 7 取余的结果。</p>
<h3 id="思路-1"><a class="header" href="#思路-1">思路</a></h3>
<p>用两个堆（优先队列）分别存储两种订单，按题目描述模拟即可。</p>
<h3 id="代码-1"><a class="header" href="#代码-1">代码</a></h3>
<pre><code class="language-java">import java.util.PriorityQueue;

public class N2 {

    private final static int MOD=(int) (1e9+7);

    public int getNumberOfBacklogOrders(int[][] orders) {
        PriorityQueue&lt;int[]&gt; sell=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        PriorityQueue&lt;int[]&gt; buy=new PriorityQueue&lt;&gt;((o1, o2)-&gt;{
            if(o1[0]==o2[0])return Integer.compare(o2[1],o1[1]);
            return Integer.compare(o2[0],o1[0]);
        });

        for (int[] order:orders)
        {
            int pricei=order[0];
            int amount=order[1];
            int[] o=sell.poll();
            //buy
            if(order[2]==0)
            {
                while (!sell.isEmpty()&amp;&amp;sell.peek()[0]&lt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount){
                        o[1]-=amount;
                        amount=0;
                        sell.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];

                }
                if(amount&gt;0)buy.add(new int[]{pricei,amount});

            }
            //sell
            else {
                while (!buy.isEmpty()&amp;&amp;buy.peek()[0]&gt;=pricei&amp;&amp;amount&gt;0)
                {
                    if(o[1]&gt;amount)
                    {
                        o[1]-=amount;
                        amount=0;
                        buy.add(o);
                    }
                    else if(o[1]==amount)
                    {
                        o[1]-=amount;
                        amount=0;
                    }
                    else amount-=o[1];
                }
                if(amount&gt;0)sell.add(new int[]{pricei,amount});
            }
        }

        long res=0L;
        while (!buy.isEmpty()){
            res+=buy.poll()[1];
            res%=MOD;
        }
        while (!sell.isEmpty()){
            res+=sell.poll()[1];
            res%=MOD;
        }
        return (int) res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsmaximum-value-at-a-given-index-in-a-bounded-array有界数组中指定下标处的最大值a">题三 <a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">有界数组中指定下标处的最大值</a></a></h2>
<h3 id="描述-2"><a class="header" href="#描述-2">描述</a></h3>
<p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：</p>
<p>nums.length == n
nums[i] 是 正整数 ，其中 0 &lt;= i &lt; n
abs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1
nums 中所有元素之和不超过 maxSum
nums[index] 的值被 最大化
返回你所构造的数组中的 nums[index] 。</p>
<p>注意：abs(x) 等于 x 的前提是 x &gt;= 0 ；否则，abs(x) 等于 -x 。</p>
<h3 id="思路-2"><a class="header" href="#思路-2">思路</a></h3>
<ul>
<li>最大值的情况，从index处递减至1。</li>
<li>二分找出index处最大的值。</li>
</ul>
<h3 id="代码-2"><a class="header" href="#代码-2">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public static void main(String[] args) {
        System.out.println(new N3().maxValue(6, 1, 10));
    }

    public int maxValue(int n, int index, int maxSum) {
        int res=1;
        int left=res, right=maxSum;
        while (left&lt;=right) {
            int mid=(left+right)/2;
            if (check(mid, n, index, maxSum)) {
                res=mid;
                left=mid+1;
            } else right=mid-1;
        }
        return res;
    }

    private boolean check(int max, int n, int index, int maxSum) {
        int sum=0;
        int l=max,lIdx=index;
        while (l&gt;1&amp;&amp;lIdx&gt;=0)
        {
            sum+=l;
            if(sum&gt;maxSum)return false;
            l--;
            lIdx--;
        }
        if(lIdx&gt;=0)sum+=lIdx+1;
        if(sum&gt;maxSum)return false;
        sum-=max;
        int r=max,rIdx=index;
        while (r&gt;1&amp;&amp;rIdx&lt;n){
            sum+=r;
            if(sum&gt;maxSum)return false;
            r--;
            rIdx++;
        }
        if(rIdx!=n)sum+=(n-rIdx);
        // System.out.println(sum);
        return sum&lt;=maxSum;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemscount-pairs-with-xor-in-a-range统计异或值在范围内的数对有多少a">题四 <a href="https://leetcode-cn.com/problems/count-pairs-with-xor-in-a-range/">统计异或值在范围内的数对有多少</a></a></h2>
<h3 id="描述-3"><a class="header" href="#描述-3">描述</a></h3>
<p>给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。</p>
<p>漂亮数对 是一个形如 (i, j) 的数对，其中 0 &lt;= i &lt; j &lt; nums.length 且 low &lt;= (nums[i] XOR nums[j]) &lt;= high 。</p>
<h3 id="思路-3"><a class="header" href="#思路-3">思路</a></h3>
<p>待补充</p>
<h3 id="代码-3"><a class="header" href="#代码-3">代码</a></h3>
<p>待补充</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第234场周赛"><a class="header" href="#力扣第234场周赛">力扣第234场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-234problemsnumber-of-different-integers-in-a-string字符串中不同整数的数目a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-234/problems/number-of-different-integers-in-a-string/">字符串中不同整数的数目</a></a></h2>
<h3 id="描述-4"><a class="header" href="#描述-4">描述</a></h3>
<p>给你一个字符串 <code>word</code> ，该字符串由数字和小写英文字母组成。</p>
<p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123 34 8 34&quot;</code> 。注意，剩下的这些整数间至少要用一个空格隔开：<code>&quot;123&quot;</code>、<code>&quot;34&quot;</code>、<code>&quot;8&quot;</code> 和 <code>&quot;34&quot;</code> 。</p>
<p>返回对 <code>word</code> 完成替换后形成的 <strong>不同</strong> 整数的数目。</p>
<p>如果两个整数的 <strong>不含前导零</strong> 的十进制表示不同，则认为这两个整数也不同。</p>
<p> <!-- more --></p>
<h3 id="思路-4"><a class="header" href="#思路-4">思路</a></h3>
<p>一次遍历，将数字存入Set中，注意前导零。</p>
<h3 id="代码-4"><a class="header" href="#代码-4">代码</a></h3>
<pre><code class="language-java">import java.util.HashSet;
import java.util.Set;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:16 上午
 */
public class N1 {
    public int numDifferentIntegers(String word) {
        int idx=0;
        char[] strs=word.toCharArray();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        while (idx&lt;word.length())
        {
            while (idx&lt;word.length()&amp;&amp;!Character.isDigit(strs[idx]))idx++;
            StringBuilder sb=new StringBuilder();
            while (idx&lt;word.length()&amp;&amp;strs[idx]=='0')idx++;
            while (idx&lt;word.length()&amp;&amp;Character.isDigit(strs[idx]))
            {
                sb.append(strs[idx]);
                idx++;
            }
            if(sb.length()==0&amp;&amp;idx&gt;=1&amp;&amp;strs[idx-1]=='0')sb.append(&quot;0&quot;);
            if(sb.length()!=0)set.add(sb.toString());
        }
        return set.size();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-operations-to-reinitialize-a-permutation还原排列的最少操作步数a">题二 <a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">还原排列的最少操作步数</a></a></h2>
<h3 id="描述-5"><a class="header" href="#描述-5">描述</a></h3>
<p>给你一个偶数 n ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i（下标 从 0 开始 计数）。</p>
<p>一步操作中，你将创建一个新数组 arr ，对于每个 i ：</p>
<p>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]
如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]
然后将 arr 赋值给 perm 。</p>
<p>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。</p>
<h3 id="思路-5"><a class="header" href="#思路-5">思路</a></h3>
<p>直接按题目要求模拟。</p>
<h3 id="代码-5"><a class="header" href="#代码-5">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public static void main(String[] args) {
        System.out.println(new N2().reinitializePermutation(4));
    }
    public int reinitializePermutation(int n) {
        int[] arr=new int[n];
        int[] tmp=new int[n];
        for (int i=0;i&lt;n;i++)arr[i]=i;
        for (int res=1;res&lt;4;res++)
        {
            //System.out.println(Arrays.toString(arr));
            for (int i=0;i&lt;n;i++)
            {
                if(i%2==0) tmp[i]=arr[i/2];
                else if(i%2==1) tmp[i]=arr[n/2+(i-1)/2];
            }
            System.arraycopy(tmp, 0, arr, 0, n);
            boolean flag=true;
            for (int i=0;i&lt;n;i++)
            {
                if(arr[i]!=i){
                    flag=false;
                    break;
                }
            }
            if(flag)return res;
        }
        return -1;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsevaluate-the-bracket-pairs-of-a-string替换字符串中的括号内容a">题三 <a href="https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/">替换字符串中的括号内容</a></a></h2>
<h3 id="描述-6"><a class="header" href="#描述-6">描述</a></h3>
<p>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。</p>
<p>比方说，字符串 &quot;(name)is(age)yearsold&quot; 中，有 两个 括号对，分别包含键 &quot;name&quot; 和 &quot;age&quot; 。
你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。</p>
<p>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：</p>
<p>将 keyi 和括号用对应的值 valuei 替换。
如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 &quot;?&quot; 替换（不需要引号）。
knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。</p>
<p>请你返回替换 所有 括号对后的结果字符串。</p>
<h3 id="思路-6"><a class="header" href="#思路-6">思路</a></h3>
<ul>
<li>将knowledge变为map方便使用</li>
<li>一次遍历，解析出括号内的key</li>
</ul>
<h3 id="代码-6"><a class="header" href="#代码-6">代码</a></h3>
<pre><code class="language-java">import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/3/28 10:17 上午
 */
public class N3 {

    public String evaluate(String s, List&lt;List&lt;String&gt;&gt; knowledge) {
        Map&lt;String,String&gt; map=new HashMap&lt;&gt;(knowledge.size()*2+5);
        for (List&lt;String&gt; know:knowledge)map.put(know.get(0),know.get(1));
        StringBuilder res=new StringBuilder();
        char[] strs=s.toCharArray();
        int idx=0;
        while (idx&lt;strs.length)
        {
            while (idx&lt;strs.length&amp;&amp;strs[idx]!='(') res.append(strs[idx++]);
            StringBuilder key=new StringBuilder();
            idx++;
            while (idx&lt;strs.length&amp;&amp;strs[idx]!=')') key.append(strs[idx++]);
            idx++;
            if(key.length()&gt;0)res.append(map.getOrDefault(key.toString(),&quot;?&quot;));
        }
        return res.toString();
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsmaximize-number-of-nice-divisors好因子的最大数目a">题四 <a href="https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/">好因子的最大数目</a></a></h2>
<h3 id="描述-7"><a class="header" href="#描述-7">描述</a></h3>
<p>给你一个正整数 primeFactors 。你需要构造一个正整数 n ，它满足以下条件：</p>
<p>n 质因数（质因数需要考虑重复的情况）的数目 不超过 primeFactors 个。
n 好因子的数目最大化。如果 n 的一个因子可以被 n 的每一个质因数整除，我们称这个因子是 好因子 。比方说，如果 n = 12 ，那么它的质因数为 [2,2,3] ，那么 6 和 12 是好因子，但 3 和 4 不是。
请你返回 n 的好因子的数目。由于答案可能会很大，请返回答案对 109 + 7 取余 的结果。</p>
<p>请注意，一个质数的定义是大于 1 ，且不能被分解为两个小于该数的自然数相乘。一个数 n 的质因子是将 n 分解为若干个质因子，且它们的乘积为 n 。</p>
<h3 id="思路-7"><a class="header" href="#思路-7">思路</a></h3>
<p>这题一开始想复杂了，总想着把这个正整数找出来。其实这题不需要把这个正整数找出来。</p>
<p>对num进行质因数分解</p>
<pre><code>num=a1^k1*a2^k2.....
</code></pre>
<p>按题目要求可得</p>
<pre><code>k1+k2+.....&lt;=primeFactors
</code></pre>
<p>好因子必须包含有</p>
<pre><code>a1*a2*....
</code></pre>
<p>这个因数。</p>
<p>题目是求好因子数目的最大化的，也就是求</p>
<pre><code>k1*k2*...
</code></pre>
<p>的最大值</p>
<p>如何拆才能尽可能最大，尽可能拆成3。</p>
<p>选择3的理由如下：</p>
<p>依据<strong>均值不等式</strong>可得拆分成想等的值的时候乘积最大。</p>
<p>如果对n进行x份等值拆分可得y=(n/x)^x</p>
<p>可得x=e时，y最大。</p>
<p>最接近e的整数为3。</p>
<h3 id="代码-7"><a class="header" href="#代码-7">代码</a></h3>
<pre><code class="language-java">public class N4 {

    private final static int MOD=(int) (1e9+7);

    public int maxNiceDivisors(int primeFactors) {
        if (primeFactors&lt;=3) return primeFactors;
        if (primeFactors%3==1) return (int) (powMod(3, (primeFactors-4)/3, MOD)*4%MOD);
        if (primeFactors%3==2) return (int) (powMod(3, primeFactors/3, MOD)*2%MOD);
        return (int) (powMod(3, primeFactors/3, MOD));
    }
    //快速幂
    long powMod(long a, long b, final long mod) {
        if (b==0) return 1L;
        long res=powMod(a, b/2, mod)%mod;
        if (b%2==0) return res*res%mod;
        return res*res*a%mod;
    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第235场周赛"><a class="header" href="#力扣第235场周赛">力扣第235场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemstruncate-sentence截断句子a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/truncate-sentence/">截断句子</a></a></h2>
<h3 id="描述-8"><a class="header" href="#描述-8">描述</a></h3>
<p><strong>句子</strong> 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>
<ul>
<li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code> 和 <code>&quot;hello world hello world&quot;</code> 都是句子。</li>
</ul>
<p>给你一个句子 <code>s</code> 和一个整数 <code>k</code> ，请你将 <code>s</code> <strong>截断</strong> ，使截断后的句子仅含 <strong>前</strong> <code>k</code> 个单词。返回 <strong>截断</strong> <code>s</code>后得到的句子。</p>
<p> <!-- more --></p>
<h3 id="思路-8"><a class="header" href="#思路-8">思路</a></h3>
<ul>
<li>按空格切分句子获得单词</li>
<li>按题目要求拼成截断后的句子</li>
</ul>
<h3 id="代码-8"><a class="header" href="#代码-8">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public String truncateSentence(String s, int k) {
        String[] strs=s.split(&quot; &quot;);
        StringBuilder sb=new StringBuilder();
        for (int i=0;i&lt;k;i++)sb.append(strs[i]).append(&quot; &quot;);
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsfinding-the-users-active-minutes查找用户活跃分钟数a">题二 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/finding-the-users-active-minutes/">查找用户活跃分钟数</a></a></h2>
<h3 id="描述-9"><a class="header" href="#描述-9">描述</a></h3>
<p>给你用户在 LeetCode 的操作日志，和一个整数 <code>k</code> 。日志用一个二维整数数组 <code>logs</code> 表示，其中每个 <code>logs[i] = [IDi, timei]</code> 表示 ID 为 <code>IDi</code> 的用户在 <code>timei</code> 分钟时执行了某个操作。</p>
<p><strong>多个用户</strong> 可以同时执行操作，单个用户可以在同一分钟内执行 <strong>多个操作</strong> 。</p>
<p>指定用户的 <strong>用户活跃分钟数（user active minutes，UAM）</strong> 定义为用户对 LeetCode 执行操作的 <strong>唯一分钟数</strong> 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>
<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 <code>k</code> 且 <strong>下标从 1 开始计数</strong> 的数组 <code>answer</code> ，对于每个 <code>j</code>（<code>1 &lt;= j &lt;= k</code>），<code>answer[j]</code> 表示 <strong>用户活跃分钟数</strong> 等于 <code>j</code> 的用户数。</p>
<p>返回上面描述的答案数组 <code>answer</code> 。</p>
<h3 id="思路-9"><a class="header" href="#思路-9">思路</a></h3>
<p>把日志记录存在</p>
<pre><code class="language-java">Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
</code></pre>
<p>Key 是用户ID，Value存的是活跃时间的集合。</p>
<p>接着遍历map即可得到答案。</p>
<h3 id="代码-9"><a class="header" href="#代码-9">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int[] findingUsersActiveMinutes(int[][] logs, int k) {
        Map&lt;Integer,Set&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();
        for (int[] log:logs){
            if(! map.containsKey(log[0]))map.put(log[0],new HashSet&lt;&gt;());
            map.get(log[0]).add(log[1]);
        }
        int[] res=new int[k];
        for (Map.Entry&lt;Integer,Set&lt;Integer&gt;&gt; e:map.entrySet()){
            res[e.getValue().size()-1]++;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsminimum-absolute-sum-difference绝对差值和a">题三 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/minimum-absolute-sum-difference/">绝对差值和</a></a></h2>
<h3 id="描述-10"><a class="header" href="#描述-10">描述</a></h3>
<p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p>
<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p>
<p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p>
<p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><code>|x|</code> 定义为：</p>
<ul>
<li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li>
<li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li>
</ul>
<h3 id="思路-10"><a class="header" href="#思路-10">思路</a></h3>
<ul>
<li>先求出绝对差值和。</li>
<li>对每一个位置idx的nums1[idx]尝试替换成最接近nums2[idx]的值</li>
<li>通过二分查找num1中最接近nums2[idx]的值</li>
<li>遍历所有idx</li>
</ul>
<h3 id="代码-10"><a class="header" href="#代码-10">代码</a></h3>
<pre><code class="language-java">public class N3 {

    private final static int MOD=(int) (1e9+7);

    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long sum=0L;
        long min=0L;
        for (int i=0;i&lt;nums1.length;i++)
        {
            sum+=Math.abs(nums1[i]-nums2[i]);
        }
        int[] arr=new int[nums1.length];
        System.arraycopy(nums1, 0, arr, 0, arr.length);
        min=sum;

        Arrays.sort(arr);

        for (int i=0;i&lt;nums1.length;i++)
        {
            int idx=find(nums2[i],arr);
            for (int j=Math.max(0,idx-2);j&lt;=Math.min(idx+2,arr.length-1);j++)
            {
                long tmp=sum-Math.abs(nums1[i]-nums2[i])+Math.abs(arr[j]-nums2[i]);
                min=Math.min(min,tmp);
            }
        }
        return (int) (min%MOD);

    }

    private int find(int tar, int[] arr) {
        if(tar&lt;=arr[0])return 0;
        if(tar&gt;=arr[arr.length-1])return arr.length-1;
        int left=0,right=arr.length-1;
        int res=right;
        while (left&lt;=right){
            int mid=(left+right)/2;
            if(arr[mid]==tar)return mid;
            if(arr[mid]&gt;tar){
                res=mid;
                right=mid-1;
            }
            else left=mid+1;
        }
        return res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-235problemsnumber-of-different-subsequences-gcds序列中不同最大公约数的数目a">题四 <a href="https://leetcode-cn.com/contest/weekly-contest-235/problems/number-of-different-subsequences-gcds/">序列中不同最大公约数的数目</a></a></h2>
<h3 id="描述-11"><a class="header" href="#描述-11">描述</a></h3>
<p>给你一个由正整数组成的数组 <code>nums</code> 。</p>
<p>数字序列的 <strong>最大公约数</strong> 定义为序列中所有整数的共有约数中的最大整数。</p>
<ul>
<li>例如，序列 <code>[4,6,16]</code> 的最大公约数是 <code>2</code> 。</li>
</ul>
<p>数组的一个 <strong>子序列</strong> 本质是一个序列，可以通过删除数组中的某些元素（或者不删除）得到。</p>
<ul>
<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,**2**,4,1,**5**,**10**]</code> 的一个子序列。</li>
</ul>
<p>计算并返回 <code>nums</code> 的所有 <strong>非空</strong> 子序列中 <strong>不同</strong> 最大公约数的 <strong>数目</strong> 。</p>
<h3 id="思路-11"><a class="header" href="#思路-11">思路</a></h3>
<ul>
<li>
<p>预计算算出这个范围内数的所有因数</p>
</li>
<li>
<p>如果一个序列中能被K整除有m个，被tk(t&gt;1,且t为整数)整除的数也有m个，那么如果k是一个序列的公约数，tk也是这个序列的公约数。</p>
<p>所以能被K整除个数不等于能被tk整除个数，那么k是一个最大公约数。</p>
</li>
</ul>
<h3 id="代码-11"><a class="header" href="#代码-11">代码</a></h3>
<pre><code class="language-java">public class N4 {
    private final static int MAX=2*100000+1;
    private final static List&lt;Integer&gt;[] factors=new List[MAX];
    private final static int[] book=new int[MAX];
    static{
        //预计算
        for (int i=1;i&lt;MAX;i++)factors[i]=new ArrayList&lt;&gt;();
        for (int i=1;i&lt;MAX;i++){
            for (int j=i;j&lt;MAX;j+=i){
                factors[j].add(i);
            }
        }
    }

    public int countDifferentSubsequenceGCDs(int[] nums) {
        int max=0;
        for (int i:nums)max=Math.max(max,i);
        Arrays.fill(book,0);
        for (int num:nums){
            for (int factor:factors[num]){
                book[factor]++;
            }
        }

        int res=0;
        for (int i=max;i&gt;=1;i--){
            if(book[i]==0)continue;
            boolean flag=true;
            for (int j=i*2;j&lt;=max;j+=i){
                if(book[i]==book[j]){
                    flag=false;
                    break;
                }
            }
            if(flag)res++;
        }
        return res;

    }

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第236场周赛"><a class="header" href="#力扣第236场周赛">力扣第236场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemssign-of-the-product-of-an-array数组元素积的符号a">题一 <a href="https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/">数组元素积的符号</a></a></h2>
<h3 id="描述-12"><a class="header" href="#描述-12">描述</a></h3>
<p>已知函数 signFunc(x) 将会根据 x 的正负返回特定值：</p>
<p>如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。</p>
<p>返回 signFunc(product) 。</p>
<p> <!-- more --></p>
<h3 id="思路-12"><a class="header" href="#思路-12">思路</a></h3>
<p>本题可以转换成求负数个数。</p>
<h3 id="代码-12"><a class="header" href="#代码-12">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int arraySign(int[] nums) {
        int cnt1=0;
        for (int i:nums)
        {
            if(i==0)return 0;
            if(i&lt;0)cnt1++;
        }
        if(cnt1%2==0)return 1;
        return -1;
    }   
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsfind-the-winner-of-the-circular-game找出游戏的获胜者a">题二 <a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">找出游戏的获胜者</a></a></h2>
<h3 id="描述-13"><a class="header" href="#描述-13">描述</a></h3>
<p>共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 &lt;= i &lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。</p>
<p>游戏遵循如下规则：</p>
<p>从第 1 名小伙伴所在位置 开始 。
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
否则，圈子中最后一名小伙伴赢得游戏。
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。</p>
<h3 id="思路-13"><a class="header" href="#思路-13">思路</a></h3>
<ul>
<li>看成队列</li>
<li>模拟游戏规则</li>
</ul>
<h3 id="代码-13"><a class="header" href="#代码-13">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int findTheWinner(int n, int k) {
        Queue&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;();
        for (int i=1;i&lt;=n;i++){
            queue.add(i);
        }
        int cur=k;
        while (queue.size()&gt;1){
            cur--;
            int p=queue.poll();
            if(cur!=0)queue.add(p);
            else cur=k;
        }
        return queue.poll();
    }
}
</code></pre>
<h2 id="题三"><a class="header" href="#题三">题三</a></h2>
<h3 id="描述-14"><a class="header" href="#描述-14">描述</a></h3>
<p>给你一个长度为 n 的 3 跑道道路 ，它总共包含 n + 1 个 点 ，编号为 0 到 n 。一只青蛙从 0 号点第二条跑道 出发 ，它想要跳到点 n 处。然而道路上可能有一些障碍。</p>
<p>给你一个长度为 n + 1 的数组 obstacles ，其中 obstacles[i] （取值范围从 0 到 3）表示在点 i 处的 obstacles[i] 跑道上有一个障碍。如果 obstacles[i] == 0 ，那么点 i 处没有障碍。任何一个点的三条跑道中 最多有一个 障碍。</p>
<p>比方说，如果 obstacles[2] == 1 ，那么说明在点 2 处跑道 1 有障碍。
这只青蛙从点 i 跳到点 i + 1 且跑道不变的前提是点 i + 1 的同一跑道上没有障碍。为了躲避障碍，这只青蛙也可以在 同一个 点处 侧跳 到 另外一条 跑道（这两条跑道可以不相邻），但前提是跳过去的跑道该点处没有障碍。</p>
<p>比方说，这只青蛙可以从点 3 处的跑道 3 跳到点 3 处的跑道 1 。
这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。</p>
<p>注意：点 0 处和点 n 处的任一跑道都不会有障碍。</p>
<h3 id="思路-14"><a class="header" href="#思路-14">思路</a></h3>
<p>动态规划:</p>
<pre><code>dp[number][idx] 表示 在number跑道的idx位置到终点最少还需要几次
</code></pre>
<h3 id="代码-14"><a class="header" href="#代码-14">代码</a></h3>
<pre><code class="language-java">class Solution {
    public int minSideJumps(int[] obstacles) {
        int[][] dp=new int[3][obstacles.length];
        for (int i=0;i&lt;3;i++) Arrays.fill(dp[i],-1);
        int res=slove(2, 0, obstacles, dp);
        return res;
    }

    private int slove(int number, int idx, int[] obstacles, int[][] dp) {
        if(dp[number-1][idx]!=-1)return dp[number-1][idx];
        int res=Integer.MAX_VALUE&gt;&gt;1;
        if(idx==obstacles.length-1)return 0;
        if(obstacles[idx+1]!=number)res=slove(number,idx+1,obstacles,dp);
        else {
            for (int i=1;i&lt;=3;i++)
            {
                if(obstacles[idx]==i||obstacles[idx+1]==i)continue;
                res=Math.min(res,1+slove(i,idx,obstacles,dp));
            }
        }
        return dp[number-1][idx]=res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfinding-mk-average求出-mk-平均值a">题四 <a href="https://leetcode-cn.com/problems/finding-mk-average/">求出 MK 平均值</a></a></h2>
<h3 id="描述-15"><a class="header" href="#描述-15">描述</a></h3>
<p>给你两个整数 m 和 k ，以及数据流形式的若干整数。你需要实现一个数据结构，计算这个数据流的 MK 平均值 。</p>
<p>MK 平均值 按照如下步骤计算：</p>
<p>如果数据流中的整数少于 m 个，MK 平均值 为 -1 ，否则将数据流中最后 m 个元素拷贝到一个独立的容器中。
从这个容器中删除最小的 k 个数和最大的 k 个数。
计算剩余元素的平均值，并 向下取整到最近的整数 。
请你实现 MKAverage 类：</p>
<p>MKAverage(int m, int k) 用一个空的数据流和两个整数 m 和 k 初始化 MKAverage 对象。
void addElement(int num) 往数据流中插入一个新的元素 num 。
int calculateMKAverage() 对当前的数据流计算并返回 MK 平均数 ，结果需 向下取整到最近的整数 。</p>
<h3 id="思路-15"><a class="header" href="#思路-15">思路</a></h3>
<ul>
<li>用4颗TreeSet树，一颗维护最小的K个值，一颗维护小的临时值，一颗维护最大的K个值，一颗维护最大的临时K个值。</li>
<li>临时值的两颗树存在的意义：用来存储未过期的值，在对应的小树和大树个树不够的时候补充。</li>
<li>用一个队列维护没有过期的值。</li>
<li>对最小树、最大树和队列操作的同时维护各自的sum。</li>
</ul>
<h3 id="代码-15"><a class="header" href="#代码-15">代码</a></h3>
<pre><code class="language-java">import java.util.*;

/**
 * author: fangjie
 * email: syfangjie@live.cn
 * date: 2021/4/11 11:03 上午
 */
public class N4 {
    //[&quot;MKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;,&quot;addElement&quot;,&quot;calculateMKAverage&quot;,&quot;addElement&quot;]
    //[[3,1],[58916],[61899],[],[85406],[49757],[],[27520],[12303],[],[63945]]
    public static void main(String[] args) {
        MKAverage mkAverage = new MKAverage(3, 1);
        mkAverage.addElement(58916);
        mkAverage.addElement(61899);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(85406);
        mkAverage.addElement(49757);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(27520);
        mkAverage.addElement(12303);
        System.out.println(mkAverage.calculateMKAverage());
        mkAverage.addElement(63945);
    }
}
class MKAverage {

    private final int m;
    private final int k;

    private int sum;
    private int size;

    private Queue&lt;int[]&gt; queue;
    private int minSum;
    private TreeSet&lt;int[]&gt; min;
    private TreeSet&lt;int[]&gt; minT;

    private int maxSum;
    private TreeSet&lt;int[]&gt; max;
    private TreeSet&lt;int[]&gt; maxT;


    public MKAverage(int m, int k) {
        this.m=m;
        this.k=k;
        this.sum=this.maxSum=this.minSum=this.size=0;
        this.queue=new ArrayDeque&lt;&gt;();
        min=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        minT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });
        max=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
        maxT=new TreeSet&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o2[0],o1[0]);
        });
    }

    public void addElement(int num) {
        size++;
        int[] cur = {num, size};
        sum+=num;
        queue.add(cur);
        if(queue.size()&gt;m){
            int[] c = queue.poll();
            sum-=c[0];
            minT.remove(c);
            if(min.remove(c))minSum-=c[0];
            maxT.remove(c);
            if(max.remove(c))maxSum-=c[0];

        }
        minSum+=help(min,minT,cur);
        maxSum+=help(max,maxT,cur);
    }
    private int help(TreeSet&lt;int[]&gt; set,TreeSet&lt;int[]&gt;tSet,int[] cur){
        int res=0;
        while (set.size()&lt;k&amp;&amp;!tSet.isEmpty()){
            int[] c=tSet.pollFirst();
            res+=c[0];
            set.add(c);
        }
        set.add(cur);
        res+=cur[0];
        while (set.size()&gt;k){
            int[] c=set.pollLast();
            res-=c[0];
            tSet.add(c);
        }
        return res;
    }

    public int calculateMKAverage() {
        if(queue.size()&lt;m)return -1;
        //System.out.println(Arrays.toString(new int[]{sum,minSum,maxSum}));
        return (sum-minSum-maxSum)/(m-2*k);
    }
}
/**
 * Your MKAverage object will be instantiated and called as such:
 * MKAverage obj = new MKAverage(m, k);
 * obj.addElement(num);
 * int param_2 = obj.calculateMKAverage();
 */
/*

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第237场周赛"><a class="header" href="#力扣第237场周赛">力扣第237场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemscheck-if-the-sentence-is-pangram判断句子是否为全字母句a">题一 <a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></a></h2>
<h3 id="描述-16"><a class="header" href="#描述-16">描述</a></h3>
<p>全字母句 指包含英语字母表中每个字母至少一次的句子。</p>
<p>给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。</p>
<p>如果是，返回 true ；否则，返回 false 。</p>
<p> <!-- more --></p>
<h3 id="思路-16"><a class="header" href="#思路-16">思路</a></h3>
<p>用一个数组记录字母是否出现。</p>
<h3 id="代码-16"><a class="header" href="#代码-16">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public boolean checkIfPangram(String sentence) {
        int[] book=new int[26];
        for (char c:sentence.toCharArray()) book[c-'a']++;
        for (int i:book)if(i==0)return false;
        return true;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-ice-cream-bars雪糕的最大数量a">题二 <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></a></h2>
<h3 id="描述-17"><a class="header" href="#描述-17">描述</a></h3>
<p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p>
<p>商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。</p>
<p>给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。</p>
<p>注意：Tony 可以按任意顺序购买雪糕。</p>
<h3 id="思路-17"><a class="header" href="#思路-17">思路</a></h3>
<p>贪心求解即可。</p>
<h3 id="代码-17"><a class="header" href="#代码-17">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res=0;
        for (int cost:costs){
            if(coins&gt;=cost){
                res++;
                coins-=cost;
            }
            else break;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemssingle-threaded-cpu单线程-cpua">题三 <a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></a></h2>
<h3 id="描述-18"><a class="header" href="#描述-18">描述</a></h3>
<p>给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。</p>
<p>现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：</p>
<p>如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。
CPU 可以在完成一项任务后，立即开始执行一项新任务。
返回 CPU 处理任务的顺序。</p>
<h3 id="思路-18"><a class="header" href="#思路-18">思路</a></h3>
<ul>
<li>用优先队列模拟</li>
<li>记录下当前时间</li>
</ul>
<h3 id="代码-18"><a class="header" href="#代码-18">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public int[] getOrder(int[][] tasks) {
        PriorityQueue&lt;int[]&gt; pq=new PriorityQueue&lt;&gt;((o1, o2) -&gt; {
            if(o1[0]==o2[0])return Integer.compare(o1[1],o2[1]);
            return Integer.compare(o1[0],o2[0]);
        });

        PriorityQueue&lt;int[]&gt; task=new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[0]));

        for (int i=0;i&lt; tasks.length;i++){
            task.add(new int[]{tasks[i][0],tasks[i][1],i});
        }

        int[] ans=new int[tasks.length];
        int idx=0;
        int cur=0;
        while (!task.isEmpty()||!pq.isEmpty()){
            if(pq.isEmpty()&amp;&amp;cur&lt;task.peek()[0]){
                cur= task.peek()[0];
            }
            while (!task.isEmpty()&amp;&amp;cur&gt;=task.peek()[0]){
                int[] poll = task.poll();
                pq.add(new int[]{poll[1],poll[2]});
            }
            if(!pq.isEmpty()){
                int[] poll = pq.poll();
                ans[idx++]=poll[1];
                cur+=poll[0];
            }
        }

        return ans;

    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfind-xor-sum-of-all-pairs-bitwise-and所有数对按位与结果的异或和a">题四 <a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></a></h2>
<h3 id="描述-19"><a class="header" href="#描述-19">描述</a></h3>
<p>列表的 异或和（XOR sum）指对所有元素进行按位 XOR 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。</p>
<p>例如，[1,2,3,4] 的 异或和 等于 1 XOR 2 XOR 3 XOR 4 = 4 ，而 [3] 的 异或和 等于 3 。
给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。</p>
<p>根据每个 (i, j) 数对，构造一个由 arr1[i] AND arr2[j]（按位 AND 运算）结果组成的列表。其中 0 &lt;= i &lt; arr1.length 且 0 &lt;= j &lt; arr2.length 。</p>
<p>返回上述列表的 异或和 。</p>
<h3 id="思路-19"><a class="header" href="#思路-19">思路</a></h3>
<p>找规律，按位数来看，只有当每个数组在当前位为1的个数都是奇数时，最后的结果才会是1。</p>
<h3 id="代码-19"><a class="header" href="#代码-19">代码</a></h3>
<pre><code class="language-java">public class N4 {

    public int getXORSum(int[] arr1, int[] arr2) {
        int[] book1=new int[32];
        int[] book2=new int[32];
        int[] res=new int[32];
        setBook(arr1, book1);
        setBook(arr2,book2);
        for (int i=0;i&lt;32;i++) if(book1[i]%2!=0&amp;&amp;book2[i]%2!=0)res[i]=1;
        int ans=0;
        for (int i=0;i&lt;res.length;i++) if(res[i]==1)ans+=Math.pow(2,i);
        return ans;
    }

    private void setBook(int[] arr, int[] book) {
        for (int num:arr)
        {
            char[] strs = Integer.toBinaryString(num).toCharArray();
            for (int i=0;i&lt;strs.length;i++){
                book[strs.length-i-1]+=strs[i]-'0';
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第240场周赛"><a class="header" href="#力扣第240场周赛">力扣第240场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsmaximum-population-year人口最多的年份a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsmaximum-population-year人口最多的年份a">题一 <a href="https://leetcode-cn.com/problems/maximum-population-year/">人口最多的年份</a></a></h2>
<h3 id="描述-20"><a class="header" href="#描述-20">描述</a></h3>
<p>给你一个二维整数数组 logs ，其中每个 logs[i] = [birthi, deathi] 表示第 i 个人的出生和死亡年份。</p>
<p>年份 x 的 人口 定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：x 在闭区间 [birthi, deathi - 1] 内。注意，人不应当计入他们死亡当年的人口中。</p>
<p>返回 人口最多 且 最早 的年份。</p>
<p>示例 1：</p>
<p>输入：logs = [[1993,1999],[2000,2010]]
输出：1993
解释：人口最多为 1 ，而 1993 是人口为 1 的最早年份。
示例 2：</p>
<p>输入：logs = [[1950,1961],[1960,1971],[1970,1981]]
输出：1960
解释：
人口最多为 2 ，分别出现在 1960 和 1970 。
其中最早年份是 1960 。</p>
<p>提示：</p>
<p>1 &lt;= logs.length &lt;= 100
1950 &lt;= birthi &lt; deathi &lt;= 2050</p>
<h3 id="思路-20"><a class="header" href="#思路-20">思路</a></h3>
<p>用一个数组存储所有年份出生的人数减去去世的人数，然后遍历得到人口最多的年份。</p>
<h3 id="代码-20"><a class="header" href="#代码-20">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

public class N1 {
    public int maximumPopulation(int[][] logs) {
        int[] book=new int[101];
        for (int[] log:logs){
            book[log[0]-1950]++;
            book[log[1]-1950]--;
        }
        int s=0;
        int max=0;
        int res=1950;
        for (int i=0;i&lt; book.length;i++){
            s+=book[i];
            if(max&lt;s){
                max=s;
                res=i+1950;
            }
        }
        return res;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-distance-between-a-pair-of-values下标对中的最大距离a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-distance-between-a-pair-of-values下标对中的最大距离a">题二 <a href="https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/">下标对中的最大距离</a></a></h2>
<h3 id="描述-21"><a class="header" href="#描述-21">描述</a></h3>
<p>给你两个 非递增 的整数数组 nums1 和 nums2 ，数组下标均 从 0 开始 计数。</p>
<p>下标对 (i, j) 中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length 。如果该下标对同时满足 i &lt;= j 且 nums1[i] &lt;= nums2[j] ，则称之为 有效 下标对，该下标对的 距离 为 j - i 。</p>
<p>返回所有 有效 下标对 (i, j) 中的 最大距离 。如果不存在有效下标对，返回 0 。</p>
<p>一个数组 arr ，如果每个 1 &lt;= i &lt; arr.length 均有 arr[i-1] &gt;= arr[i] 成立，那么该数组是一个 非递增 数组。</p>
<p>示例 1：</p>
<p>输入：nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
输出：2
解释：有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。
最大距离是 2 ，对应下标对 (2,4) 。
示例 2：</p>
<p>输入：nums1 = [2,2,2], nums2 = [10,10,1]
输出：1
解释：有效下标对是 (0,0), (0,1) 和 (1,1) 。
最大距离是 1 ，对应下标对 (0,1) 。
示例 3：</p>
<p>输入：nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
输出：2
解释：有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。
最大距离是 2 ，对应下标对 (2,4) 。
示例 4：</p>
<p>输入：nums1 = [5,4], nums2 = [3,2]
输出：0
解释：不存在有效下标对，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 10^5
1 &lt;= nums2.length &lt;= 10^5
1 &lt;= nums1[i], nums2[j] &lt;= 10^5
nums1 和 nums2 都是 非递增 数组</p>
<h3 id="思路-21"><a class="header" href="#思路-21">思路</a></h3>
<p>二分查找。</p>
<h3 id="代码-21"><a class="header" href="#代码-21">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

public class N2 {
    public int maxDistance(int[] nums1, int[] nums2) {
        int res=0;
        for (int i=0;i&lt;nums1.length;i++){
            if(i&gt;=nums2.length)break;
            int j=find(nums2,i,nums1[i]);
            if(j!=-1){
                res=Math.max(j-i,res);
            }
        }
        return res;
    }

    private int find(int[] nums, int i, int tar) {
        if(nums[i]&lt;tar)return -1;
        int l=i,r=nums.length-1;
        int res=i;
        while (l&lt;=r){
            int mid=(l+r)/2;
            if(nums[mid]&gt;=tar){
                res=Math.max(res,mid);
                l=mid+1;
            }
            else r=mid-1;
        }
        return res;
    }
}
</code></pre>
<h2 id="题三--a-hrefhttpsleetcode-cncomproblemsmaximum-subarray-min-product子数组最小乘积的最大值a"><a class="header" href="#题三--a-hrefhttpsleetcode-cncomproblemsmaximum-subarray-min-product子数组最小乘积的最大值a">题三  <a href="https://leetcode-cn.com/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></a></h2>
<h3 id="描述-22"><a class="header" href="#描述-22">描述</a></h3>
<p>一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。</p>
<p>比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。
给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。</p>
<p>请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。</p>
<p>子数组 定义为一个数组的 连续 部分。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,2]
输出：14
解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
2 * (2+3+2) = 2 * 7 = 14 。
示例 2：</p>
<p>输入：nums = [2,3,3,1,2]
输出：18
解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。
3 * (3+3) = 3 * 6 = 18 。
示例 3：</p>
<p>输入：nums = [3,1,5,6,4,2]
输出：60
解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。
4 * (5+6+4) = 4 * 15 = 60 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^7</p>
<h3 id="思路-22"><a class="header" href="#思路-22">思路</a></h3>
<ul>
<li>
<p>预处理sum。</p>
</li>
<li>
<p>依次遍历，假定当前值就是序列中的最小值，通过单调栈找到另一个边界计算即可。</p>
</li>
</ul>
<h3 id="代码-22"><a class="header" href="#代码-22">代码</a></h3>
<pre><code class="language-java">package JavaCode.contest.weekly.n201_300.n240;

import java.util.Stack;

public class N3 {
    public int maxSumMinProduct(int[] nums) {
        final int MOD= (int) (Math.pow(10,9)+7);
        long[] sum=new long[nums.length+1];
        for (int i=1;i&lt;=nums.length;i++){
            sum[i]=sum[i-1]+nums[i-1];
        }
        long res=0;
        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();
        for (int i=0;i&lt;nums.length;i++){
            while (!stack.isEmpty()&amp;&amp;nums[i]&lt;=nums[stack.peek()]){
                int peek=stack.pop();
                int l=stack.isEmpty()?-1:stack.peek();
                res=Math.max(res, nums[peek] * (sum[i] - sum[l + 1]));
            }
            stack.push(i);
        }
        while (!stack.isEmpty()){
            int peek=stack.pop();
            int l=stack.isEmpty()?-1:stack.peek();
            res=Math.max(res, (sum[nums.length] - sum[l + 1]) *nums[peek]);
        }
        return (int) (res%MOD);
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemslargest-color-value-in-a-directed-graph有向图中最大颜色值a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemslargest-color-value-in-a-directed-graph有向图中最大颜色值a">题四 <a href="https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/">有向图中最大颜色值</a></a></h2>
<h3 id="描述-23"><a class="header" href="#描述-23">描述</a></h3>
<p>给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。</p>
<p>给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。</p>
<p>图中一条有效 路径 是一个点序列 x1 -&gt; x2 -&gt; x3 -&gt; ... -&gt; xk ，对于所有 1 &lt;= i &lt; k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。</p>
<p>请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。</p>
<p>示例 1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/6ddJXu.jpg" alt="6ddJXu" /></p>
<p>输入：colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]]
输出：3
解释：路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 &quot;a&quot; 的节点（上图中的红色节点）。
示例 2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/4IMrd2.jpg" alt="4IMrd2" /></p>
<p>输入：colors = &quot;a&quot;, edges = [[0,0]]
输出：-1
解释：从 0 到 0 有一个环。</p>
<p>提示：</p>
<p>n == colors.length
m == edges.length
1 &lt;= n &lt;= 10^5
0 &lt;= m &lt;= 10^5
colors 只含有小写英文字母。
0 &lt;= aj, bj &lt; n</p>
<h3 id="思路-23"><a class="header" href="#思路-23">思路</a></h3>
<p>拓扑排序加动态规划</p>
<ul>
<li>
<p>如果存在环则不存在拓扑排序。</p>
</li>
<li>
<p>如果a-&gt;b，那么在拓扑排序中 b一定在a的后面，所以一条路径上点的顺序与拓扑排序的顺序是一致的。</p>
</li>
<li>
<pre><code class="language-bash">dp[next][color]=Math.mac(dp[next][color],dp[cur][color])
</code></pre>
</li>
</ul>
<h3 id="代码-23"><a class="header" href="#代码-23">代码</a></h3>
<pre><code class="language-java">import java.util.*;

public class N4 {
    public int largestPathValue(String colors, int[][] edges) {
        final int n=colors.length();
        final char[] c=colors.toCharArray();
        List&lt;Integer&gt;[] graph=new List[n];
        for (int i=0;i&lt;n;i++)graph[i]=new ArrayList&lt;&gt;();

        int[] in=new int[n];
        for (int[] e:edges){
            in[e[1]]++;
            graph[e[0]].add(e[1]);
        }

        int found=0;
        Queue&lt;Integer&gt; queue=new ArrayDeque&lt;&gt;(n);
        for (int i=0;i&lt;in.length;i++){
            if(in[i]==0)queue.add(i);
        }
        int[][] dp=new int[n][26];
        while (!queue.isEmpty()){
            int cur=queue.poll();
            found++;
            dp[cur][c[cur]-'a']++;
            for (int next:graph[cur]){
                in[next]--;
                if(in[next]==0)queue.add(next);
                for (int i=0;i&lt;26;i++){
                    dp[next][i]=Math.max(dp[cur][i],dp[next][i]);
                }
            }
            if(found&gt;n)return -1;
        }
        if(found!=n)return -1;
        int res=0;
        for (int[] d:dp){
            for (int i:d)res=Math.max(i,res);
        }

        return res;

    }


}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第241场周赛"><a class="header" href="#力扣第241场周赛">力扣第241场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemssum-of-all-subset-xor-totals找出所有子集的异或总和再求和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemssum-of-all-subset-xor-totals找出所有子集的异或总和再求和a">题一 <a href="https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/">找出所有子集的异或总和再求和</a></a></h2>
<h3 id="描述-24"><a class="header" href="#描述-24">描述«</a></h3>
<p>一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。</p>
<p>例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。
给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p>
<p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p>
<p>数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3]
输出：6
解释：[1,3] 共有 4 个子集：</p>
<ul>
<li>空子集的异或总和是 0 。</li>
<li>[1] 的异或总和为 1 。</li>
<li>[3] 的异或总和为 3 。</li>
<li>[1,3] 的异或总和为 1 XOR 3 = 2 。
0 + 1 + 3 + 2 = 6
示例 2：</li>
</ul>
<p>输入：nums = [5,1,6]
输出：28
解释：[5,1,6] 共有 8 个子集：</p>
<ul>
<li>空子集的异或总和是 0 。</li>
<li>[5] 的异或总和为 5 。</li>
<li>[1] 的异或总和为 1 。</li>
<li>[6] 的异或总和为 6 。</li>
<li>[5,1] 的异或总和为 5 XOR 1 = 4 。</li>
<li>[5,6] 的异或总和为 5 XOR 6 = 3 。</li>
<li>[1,6] 的异或总和为 1 XOR 6 = 7 。</li>
<li>[5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
示例 3：</li>
</ul>
<p>输入：nums = [3,4,5,6,7,8]
输出：480
解释：每个子集的全部异或总和值之和为 480 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 12
1 &lt;= nums[i] &lt;= 20</p>
<h3 id="思路-24"><a class="header" href="#思路-24">思路</a></h3>
<p>DFS 遍历所有可能。</p>
<h3 id="代码-24"><a class="header" href="#代码-24">代码</a></h3>
<pre><code class="language-java">public class N1 {
    private int sum;
    public int subsetXORSum(int[] nums) {
        sum=0;
        dfs(0,nums,0);
        return sum;
    }

    private void dfs(int pre, int[] nums, int idx) {
        if(idx&gt;= nums.length)return;
        final int next = pre ^ nums[idx];
        sum+=next;
        dfs(next,nums,idx+1);
        dfs(pre,nums,idx+1);
    }

}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-binary-string-alternating构成交替字符串需要的最小交换次数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-binary-string-alternating构成交替字符串需要的最小交换次数a">题二 <a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/">构成交替字符串需要的最小交换次数</a></a></h2>
<h3 id="描述-25"><a class="header" href="#描述-25">描述</a></h3>
<p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p>
<p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 &quot;010&quot; 和 &quot;1010&quot; 属于交替字符串，但 &quot;0100&quot; 不是。</p>
<p>任意两个字符都可以进行交换，不必相邻 。</p>
<p>示例 1：</p>
<p>输入：s = &quot;111000&quot;
输出：1
解释：交换位置 1 和 4：&quot;111000&quot; -&gt; &quot;101010&quot; ，字符串变为交替字符串。
示例 2：</p>
<p>输入：s = &quot;010&quot;
输出：0
解释：字符串已经是交替字符串了，不需要交换。
示例 3：</p>
<p>输入：s = &quot;1110&quot;
输出：-1</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000
s[i] 的值为 '0' 或 '1'</p>
<h3 id="思路-25"><a class="header" href="#思路-25">思路</a></h3>
<ul>
<li>统计出1和0的个数</li>
<li>如果1和0的个数差距大于1 则无法构成交替字符串</li>
<li>如果1和0的个数相等：
<ul>
<li>统计偶数位是1需要交替的次数。</li>
<li>统计偶数位是0需要交替的次数。</li>
<li>取上面的最小值。</li>
</ul>
</li>
<li>如果1的个数大于0的个数，则说明偶数位一定是1</li>
<li>如果1的个数小于0的个数，则说明偶数位一定是0。</li>
</ul>
<h3 id="代码-25"><a class="header" href="#代码-25">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int minSwaps(String s) {
        final char[] strs = s.toCharArray();
        int cnt0,cnt1;
        cnt0=cnt1=0;
        for (char c:strs){
            if(c=='0')cnt0++;
            else cnt1++;
        }
        if(Math.abs(cnt0-cnt1)!=1&amp;&amp;cnt0!=cnt1)return -1;
        int res=0;
        if(cnt0&gt;cnt1){
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='1')res++;
            }
        }
        else if(cnt0==cnt1){
            int res1=0;
            int res2=0;
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='0')res1++;
                else res2++;
            }
            res=Math.min(res1,res2);
        }
        else {
            for (int i=0;i&lt;strs.length;i+=2){
                if(strs[i]=='0')res++;
            }
        }
        return res;

    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsfinding-pairs-with-a-certain-sum找出和为指定值的下标对a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsfinding-pairs-with-a-certain-sum找出和为指定值的下标对a">题三 <a href="https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum/">找出和为指定值的下标对</a></a></h2>
<h3 id="描述-26"><a class="header" href="#描述-26">描述</a></h3>
<p>给你两个整数数组 nums1 和 nums2 ，请你实现一个支持下述两类查询的数据结构：</p>
<p>累加 ，将一个正整数加到 nums2 中指定下标对应元素上。
计数 ，统计满足 nums1[i] + nums2[j] 等于指定值的下标对 (i, j) 数目（0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length）。
实现 FindSumPairs 类：</p>
<p>FindSumPairs(int[] nums1, int[] nums2) 使用整数数组 nums1 和 nums2 初始化 FindSumPairs 对象。
void add(int index, int val) 将 val 加到 nums2[index] 上，即，执行 nums2[index] += val 。
int count(int tot) 返回满足 nums1[i] + nums2[j] == tot 的下标对 (i, j) 数目。</p>
<p>示例：</p>
<p>输入：
[&quot;FindSumPairs&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;]
[[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
输出：
[null, 8, null, 2, 1, null, null, 11]</p>
<p>解释：
FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
findSumPairs.count(7);  // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7
findSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,4,5,4]
findSumPairs.count(8);  // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8
findSumPairs.count(4);  // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4
findSumPairs.add(0, 1); // 此时 nums2 = [2,4,5,4,5,4]
findSumPairs.add(1, 1); // 此时 nums2 = [2,5,5,4,5,4]
findSumPairs.count(7);  // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7</p>
<p>提示：</p>
<p>1 &lt;= nums1.length &lt;= 1000
1 &lt;= nums2.length &lt;= 10^5
1 &lt;= nums1[i] &lt;= 10^9
1 &lt;= nums2[i] &lt;= 10^5
0 &lt;= index &lt; nums2.length
1 &lt;= val &lt;= 10^5
1 &lt;= tot &lt;= 10^9
最多调用 add 和 count 函数各 1000 次</p>
<h3 id="思路-26"><a class="header" href="#思路-26">思路</a></h3>
<ul>
<li>将数据分别额外存储在两个Map中。key是值，value是个数</li>
<li>add操作的同时更新map2相关KV对</li>
<li>求count的是遍历size小的map找出对应map的value，对数相当于两个value相乘。</li>
</ul>
<h3 id="代码-26"><a class="header" href="#代码-26">代码</a></h3>
<pre><code class="language-java">class FindSumPairs {

    private int[] nums2;
    private Map&lt;Integer,Integer&gt; map1;
    private Map&lt;Integer,Integer&gt; map2;
    public FindSumPairs(int[] nums1, int[] nums2) {
        this.nums2=nums2;
        map1=new HashMap&lt;&gt;();
        map2=new HashMap&lt;&gt;();
        for (int i:nums1)map1.put(i,map1.getOrDefault(i,0)+1);
        for (int i:nums2)map2.put(i,map2.getOrDefault(i,0)+1);
    }

    public void add(int index, int val) {
        final int cnt = map2.getOrDefault(nums2[index], 0) - 1;
        if(cnt==0)map2.remove(nums2[index]);
        else map2.put(nums2[index],cnt);
        nums2[index]+=val;
        map2.put(nums2[index],map2.getOrDefault(nums2[index],0)+1);
    }

    public int count(int tot) {
        Map&lt;Integer,Integer&gt; m1;
        Map&lt;Integer,Integer&gt; m2;
        if(map1.size()&lt;=map2.size()){
            m1=map1;
            m2=map2;
        }else {
            m1=map2;
            m2=map1;
        }
        int res=0;
        for (Map.Entry&lt;Integer,Integer&gt; e:m1.entrySet()){
            res+=e.getValue()*m2.getOrDefault(tot-e.getKey(),0);
        }
        return res;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsnumber-of-ways-to-rearrange-sticks-with-k-sticks-visible恰有-k-根木棍可以看到的排列数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsnumber-of-ways-to-rearrange-sticks-with-k-sticks-visible恰有-k-根木棍可以看到的排列数目a">题四 <a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/">恰有 K 根木棍可以看到的排列数目</a></a></h2>
<h3 id="描述-27"><a class="header" href="#描述-27">描述</a></h3>
<p>有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。</p>
<p>例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。
给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。</p>
<p>示例 1：</p>
<p>输入：n = 3, k = 2
输出：3
解释：[1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
示例 2：</p>
<p>输入：n = 5, k = 5
输出：1
解释：[1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。
可以看到的木棍已经用粗体+斜体标识。
示例 3：</p>
<p>输入：n = 20, k = 11
输出：647427950
解释：总共有 647427950 (mod 10^9 + 7) 种能满足恰好有 11 根木棍可以看到的排列。</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 1000
1 &lt;= k &lt;= n</p>
<h3 id="思路-27"><a class="header" href="#思路-27">思路</a></h3>
<p>可以将题转换成n根木棍划分成K个部分。对于每个长为 mm 的部分，对于其任意排列，我们总是可以将排列中最大的元素当作可以看到的木棍，移到该部分的开头，则剩余的木棍可以任意排列，因此每个部分的方案数为 (m-1)!(m−1)!，即为一个长为 mm 的圆排列的方案数。也就是说这是<a href="https://oi-wiki.org/math/stirling/">斯特林数</a>。</p>
<p><a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/zhuan-huan-cheng-di-yi-lei-si-te-lin-shu-2y1k/">参考</a></p>
<h3 id="代码-27"><a class="header" href="#代码-27">代码</a></h3>
<pre><code class="language-java">public class N4 {
    private final static int MOD= (int) (Math.pow(10,9)+7);
    public int rearrangeSticks(int n, int k) {
        long[][] dp=new long[n+1][k+1];
        dp[0][0]=1;
        for (int i=1;i&lt;=n;i++){
            for (int j=1;j&lt;=k;j++){
                dp[i][j]=(dp[i-1][j-1]+(i-1)*dp[i-1][j])%MOD;
            }
        }
        return (int) dp[n][k];
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第场243周赛"><a class="header" href="#力扣第场243周赛">力扣第场243周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemscheck-if-word-equals-summation-of-two-words检查某单词是否等于两单词之和a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemscheck-if-word-equals-summation-of-two-words检查某单词是否等于两单词之和a">题一 <a href="https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words/">检查某单词是否等于两单词之和</a></a></h2>
<h3 id="描述-28"><a class="header" href="#描述-28">描述</a></h3>
<p>字母的 字母值 取决于字母在字母表中的位置，从 0 开始 计数。即，'a' -&gt; 0、'b' -&gt; 1、'c' -&gt; 2，以此类推。</p>
<p>对某个由小写字母组成的字符串 s 而言，其 数值 就等于将 s 中每个字母的 字母值 按顺序 连接 并 转换 成对应整数。</p>
<p>例如，s = &quot;acb&quot; ，依次连接每个字母的字母值可以得到 &quot;021&quot; ，转换为整数得到 21 。
给你三个字符串 firstWord、secondWord 和 targetWord ，每个字符串都由从 'a' 到 'j' （含 'a' 和 'j' ）的小写英文字母组成。</p>
<p>如果 firstWord 和 secondWord 的 数值之和 等于 targetWord 的数值，返回 true ；否则，返回 false 。</p>
<h3 id="思路-28"><a class="header" href="#思路-28">思路</a></h3>
<p>直接判断</p>
<h3 id="代码-28"><a class="header" href="#代码-28">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {
        return help(firstWord)+help(secondWord)==help(targetWord);
    }

    private int help(String str) {
        StringBuilder sb=new StringBuilder();
        for (char c:str.toCharArray()){
            sb.append(c-'a');
        }
        return Integer.parseInt(sb.toString());
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-value-after-insertion插入后的最大值a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-value-after-insertion插入后的最大值a">题二 <a href="https://leetcode-cn.com/problems/maximum-value-after-insertion/">插入后的最大值</a></a></h2>
<h3 id="描述-29"><a class="header" href="#描述-29">描述</a></h3>
<p>给你一个非常大的整数 n 和一个整数数字 x ，大整数 n 用一个字符串表示。n 中每一位数字和数字 x 都处于闭区间 [1, 9] 中，且 n 可能表示一个 负数 。</p>
<p>你打算通过在 n 的十进制表示的任意位置插入 x 来 最大化 n 的 数值 。但 不能 在负号的左边插入 x 。</p>
<p>例如，如果 n = 73 且 x = 6 ，那么最佳方案是将 6 插入 7 和 3 之间，使 n = 763 。
如果 n = -55 且 x = 2 ，那么最佳方案是将 2 插在第一个 5 之前，使 n = -255 。
返回插入操作后，用字符串表示的 n 的最大值。</p>
<p>示例 1：</p>
<p>输入：n = &quot;99&quot;, x = 9
输出：&quot;999&quot;
解释：不管在哪里插入 9 ，结果都是相同的。
示例 2：</p>
<p>输入：n = &quot;-13&quot;, x = 2
输出：&quot;-123&quot;
解释：向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。</p>
<h3 id="思路-29"><a class="header" href="#思路-29">思路</a></h3>
<p>由分析得到以下两个规律</p>
<ul>
<li>对于负数，寻找到第一个比x大的数的位置，把x插在这个数前面，如果没有，插在最后。</li>
<li>对于正数，寻找到第一个比x小的数的位置，把x插在这个数前面，如果没有，插在最后。</li>
</ul>
<h3 id="代码-29"><a class="header" href="#代码-29">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public String maxValue(String n, int x) {
        final char[] strs = n.toCharArray();
        StringBuilder sb=new StringBuilder();
        int idx;
        if(n.contains(&quot;-&quot;)){
            idx=strs.length;
            for (int i=1;i&lt;strs.length;i++){
                int num=strs[i]-'0';
                if(num&gt;x){
                    idx=i;
                    break;
                }
            }
            for (int i=0;i&lt;strs.length;i++){
                sb.append(strs[i]);
                if(i==idx-1)sb.append(x);
            }
        }
        else {
            idx=strs.length;
            for (int i=0;i&lt;strs.length;i++){
                int num=strs[i]-'0';
                if(x&gt;num){
                    idx=i;
                    break;
                }
            }
            for (int i=0;i&lt;strs.length;i++){
                if(i==idx)sb.append(x);
                sb.append(strs[i]);
            }
            if(idx==strs.length)sb.append(x);
        }
        return sb.toString();
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsprocess-tasks-using-servers使用服务器处理任务a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsprocess-tasks-using-servers使用服务器处理任务a">题三 <a href="https://leetcode-cn.com/problems/process-tasks-using-servers/">使用服务器处理任务</a></a></h2>
<h3 id="描述-30"><a class="header" href="#描述-30">描述</a></h3>
<p>给你两个 下标从 0 开始 的整数数组 servers 和 tasks ，长度分别为 n 和 m 。servers[i] 是第 i 台服务器的 权重 ，而 tasks[j] 是处理第 j 项任务 所需要的时间（单位：秒）。</p>
<p>你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 0 项任务在第 0 秒可以开始处理，相应地，第 j 项任务在第 j 秒可以开始处理。处理第 j 项任务时，你需要为它分配一台 权重最小 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 下标最小 的服务器。如果一台空闲服务器在第 t 秒分配到第 j 项任务，那么在 t + tasks[j] 时它将恢复空闲状态。</p>
<p>如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 尽可能早 地处理剩余任务。 如果有多项任务等待分配，则按照 下标递增 的顺序完成分配。</p>
<p>如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。</p>
<p>构建长度为 m 的答案数组 ans ，其中 ans[j] 是第 j 项任务分配的服务器的下标。</p>
<p>返回答案数组 ans 。</p>
<p>示例 1：</p>
<p>输入：servers = [3,3,2], tasks = [1,2,3,2,1,2]
输出：[2,2,0,2,1,2]
解释：事件按时间顺序如下：</p>
<ul>
<li>0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。</li>
<li>1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。</li>
<li>2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。</li>
<li>3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。</li>
<li>4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。</li>
<li>5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。
示例 2：</li>
</ul>
<p>输入：servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
输出：[1,4,1,4,1,3,2]
解释：事件按时间顺序如下：</p>
<ul>
<li>0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。</li>
<li>1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。</li>
<li>2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。</li>
<li>3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。</li>
<li>4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。</li>
<li>5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。</li>
<li>6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。</li>
</ul>
<h3 id="思路-30"><a class="header" href="#思路-30">思路</a></h3>
<p>用三个优先队列模拟</p>
<ul>
<li>一个用来存储等待接任务的服务器</li>
<li>一个用来存储正在运行的任务的服务器</li>
<li>一个用来存储任务队列</li>
</ul>
<h3 id="代码-30"><a class="header" href="#代码-30">代码</a></h3>
<pre><code class="language-java">public class N3 {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(new N3().assignTasks(Parse.parseToIntArray(&quot;[3,3,2]&quot;)
                , Parse.parseToIntArray(&quot;[1,2,3,2,1,2]&quot;))));
    }

    public int[] assignTasks(int[] servers, int[] tasks) {
        PriorityQueue&lt;int[]&gt; readyServe = new PriorityQueue&lt;&gt;((o1, o2) -&gt; {
            if (o1[0] == o2[0]) return Integer.compare(o1[1], o2[1]);
            return Integer.compare(o1[0], o2[0]);
        });

        PriorityQueue&lt;int[]&gt; runServer = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[0]));

        PriorityQueue&lt;int[]&gt; task = new PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o[0]));

        for (int i = 0; i &lt; servers.length; i++) {
            readyServe.add(new int[]{servers[i], i});
        }

        int[] res = new int[tasks.length];
        for (int i = 0; i &lt; tasks.length; i++) {

            while (!runServer.isEmpty() &amp;&amp; runServer.peek()[0] &lt;= i) {
                final int[] poll = runServer.poll();
                readyServe.add(new int[]{poll[1], poll[2]});
            }
            task.add(new int[]{i, tasks[i]});
            help(readyServe, runServer, task, res, i);
        }
        int time = 0;
        while (!task.isEmpty()) {
            if (!runServer.isEmpty()) {
                final int[] poll = runServer.poll();
                readyServe.add(new int[]{poll[1], poll[2]});
                time = poll[0];
            }
            while (!runServer.isEmpty() &amp;&amp; runServer.peek()[0] &lt;= time) {
                final int[] poll = runServer.poll();
                readyServe.add(new int[]{poll[1], poll[2]});
            }
            help(readyServe, runServer, task, res, time);
        }

        return res;
    }

    private void help(PriorityQueue&lt;int[]&gt; readyServe, PriorityQueue&lt;int[]&gt; runServer, PriorityQueue&lt;int[]&gt; task, int[] res, int time) {
        while (!readyServe.isEmpty() &amp;&amp; !task.isEmpty()) {
            final int[] s = readyServe.poll();
            final int[] t = task.poll();
            res[t[0]] = s[1];
            runServer.add(new int[]{time + t[1], s[0], s[1]});
        }
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsminimum-skips-to-arrive-at-meeting-on-time准时抵达会议现场的最小跳过休息次数a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsminimum-skips-to-arrive-at-meeting-on-time准时抵达会议现场的最小跳过休息次数a">题四 <a href="https://leetcode-cn.com/problems/minimum-skips-to-arrive-at-meeting-on-time/">准时抵达会议现场的最小跳过休息次数</a></a></h2>
<h3 id="描述-31"><a class="header" href="#描述-31">描述</a></h3>
<p>给你一个整数 hoursBefore ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 n 条道路。道路的长度用一个长度为 n 的整数数组 dist 表示，其中 dist[i] 表示第 i 条道路的长度（单位：千米）。另给你一个整数 speed ，表示你在道路上前进的速度（单位：千米每小时）。</p>
<p>当你通过第 i 条路之后，就必须休息并等待，直到 下一个整数小时 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p>
<p>例如，如果你通过一条道路用去 1.4 小时，那你必须停下来等待，到 2 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 2 小时，就无需等待，可以直接继续。
然而，为了能准时到达，你可以选择 跳过 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p>
<p>例如，假设通过第 1 条道路用去 1.4 小时，且通过第 2 条道路用去 0.6 小时。跳过第 1 条道路的休息时间意味着你将会在恰好 2 小时完成通过第 2 条道路，且你能够立即开始通过第 3 条道路。
返回准时抵达会议现场所需要的 最小跳过次数 ，如果 无法准时参会 ，返回 -1 。</p>
<p>示例 1：</p>
<p>输入：dist = [1,3,2], speed = 4, hoursBefore = 2
输出：1
解释：
不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。
可以跳过第 1 次休息时间，共用 ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。
注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。
示例 2：</p>
<p>输入：dist = [7,3,5,5], speed = 2, hoursBefore = 10
输出：2
解释：
不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。
可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 小时抵达会议现场。
示例 3：</p>
<p>输入：dist = [7,3,5,5], speed = 1, hoursBefore = 10
输出：-1
解释：即使跳过所有的休息时间，也无法准时参加会议。</p>
<h3 id="思路-31"><a class="header" href="#思路-31">思路</a></h3>
<p>动态规划</p>
<pre><code class="language-bash">#dp[i][j] 表示第i条路休息j次的最小时间。
#dp[i][j]=Math.min(dp[i-1][j]+dist[i]/speed,dp[i-1][j-1]+dist[i]/speed)
#为了避免浮点计算乘以速度变成整数计算
#dp[i][j] 表示第i条路休息j次的最小时间乘以速度。
#dp[i][j]=Math.min(dp[i-1][j-1]+dist[i],Math.ceil((dp[i-1][j]+dist[i])/speed)*speed)
</code></pre>
<h3 id="代码-31"><a class="header" href="#代码-31">代码</a></h3>
<pre><code class="language-java">import java.util.Arrays;

public class N4 {

    public int minSkips(int[] dist, int speed, int hoursBefore) {
        final long MAX=Long.MAX_VALUE&gt;&gt;2;
        final long[][] dp =new long[dist.length+1][dist.length+1];
        for (long[] arr:dp) Arrays.fill(arr,MAX);
        dp[0][0]=0;
        for (int i=1;i&lt;dp.length;i++){
            for (int j=0;j&lt;=i;j++){
                if(i!=j) dp[i][j] = Math.min(dp[i][j],(long) Math.ceil((dp[i-1][j]+dist[i-1])*1.0/speed)*speed);
                if(j!=0) dp[i][j] = Math.min(dp[i][j],dp[i-1][j-1]+dist[i-1]);
            }
        }
        for (int j=0;j&lt; dp.length;j++){
            if(dp[dp.length-1][j] &lt;= (long) hoursBefore *speed)return j;
        }
        return -1;
    }
}
</code></pre>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<p>不进则退，空了一礼拜没打，排名刷新下限。</p>
<p><img src="https://i.loli.net/2021/06/02/mepnho6SBQdrA1b.jpg" alt="mepnho6SBQdrA1b" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第244场周赛"><a class="header" href="#力扣第244场周赛">力扣第244场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsdetermine-whether-matrix-can-be-obtained-by-rotation判断矩阵经轮转后是否一致a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsdetermine-whether-matrix-can-be-obtained-by-rotation判断矩阵经轮转后是否一致a">题一 <a href="https://leetcode-cn.com/contest/weekly-contest-244/problems/determine-whether-matrix-can-be-obtained-by-rotation/">判断矩阵经轮转后是否一致</a></a></h2>
<h3 id="描述-32"><a class="header" href="#描述-32">描述</a></h3>
<p>给你两个大小为 <code>n x n</code> 的二进制矩阵 <code>mat</code> 和 <code>target</code> 。现 <strong>以 90 度顺时针轮转</strong> 矩阵 <code>mat</code> 中的元素 <strong>若干次</strong> ，如果能够使 <code>mat</code> 与 <code>target</code> 一致，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/05/20/grid3.png" alt="img" /></p>
<pre><code>输入：mat = [[0,1],[1,0]], target = [[1,0],[0,1]]
输出：true
解释：顺时针轮转 90 度一次可以使 mat 和 target 一致。
</code></pre>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/05/20/grid4.png" alt="img" /></p>
<pre><code>输入：mat = [[0,1],[1,1]], target = [[1,0],[0,1]]
输出：false
解释：无法通过轮转矩阵中的元素使 equal 与 target 一致。
</code></pre>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/05/26/grid4.png" alt="img" /></p>
<pre><code>输入：mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]
输出：true
解释：顺时针轮转 90 度两次可以使 mat 和 target 一致。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == mat.length == target.length</code></li>
<li><code>n == mat[i].length == target[i].length</code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>mat[i][j]</code> 和 <code>target[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ul>
<h3 id="思路-32"><a class="header" href="#思路-32">思路</a></h3>
<p>模拟。</p>
<p>顺时针旋转90度。</p>
<pre><code class="language-java">next[i][j]=mat[j][n-i-1];
</code></pre>
<h3 id="代码-32"><a class="header" href="#代码-32">代码</a></h3>
<pre><code class="language-java">public class N1 {
    public boolean findRotation(int[][] mat, int[][] target) {
        int i=4;
        while (i--&gt;0){
            mat=help(mat);
            if(check(mat,target))return true;
        }
        return false;
    }

    private boolean check(int[][] mat, int[][] target) {
       final int n=mat.length;
       for (int i=0;i&lt;n;i++){
           for (int j=0;j&lt;n;j++){
               if(mat[i][j]!=target[i][j])return false;
           }
       }
       return true;
    }

    private int[][] help(int[][] mat) {
        final int n= mat.length;
        int[][] res=new int[mat.length][mat.length];
        for (int i=0;i&lt;n;i++){
            for (int j=0;j&lt;n;j++){
                res[i][j]=mat[j][n-i-1];
            }
        }
        return res;
    }

}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsreduction-operations-to-make-the-array-elements-equal使数组元素相等的减少操作次数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsreduction-operations-to-make-the-array-elements-equal使数组元素相等的减少操作次数a">题二 <a href="https://leetcode-cn.com/contest/weekly-contest-244/problems/reduction-operations-to-make-the-array-elements-equal/">使数组元素相等的减少操作次数</a></a></h2>
<h3 id="描述-33"><a class="header" href="#描述-33">描述</a></h3>
<p>给你一个整数数组 <code>nums</code> ，你的目标是令 <code>nums</code> 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤：</p>
<ol>
<li>找出 <code>nums</code> 中的 <strong>最大</strong> 值。记这个值为 <code>largest</code> 并取其下标 <code>i</code> （<strong>下标从 0 开始计数</strong>）。如果有多个元素都是最大值，则取最小的 <code>i</code> 。</li>
<li>找出 <code>nums</code> 中的 <strong>下一个最大</strong> 值，这个值 <strong>严格小于</strong> <code>largest</code> ，记为 <code>nextLargest</code> 。</li>
<li>将 <code>nums[i]</code> 减少到 <code>nextLargest</code> 。</li>
</ol>
<p>返回使 <code>nums</code> 中的所有元素相等的操作次数。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [5,1,3]
输出：3
解释：需要 3 次操作使 nums 中的所有元素相等：
1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [3,1,3] 。
2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [1,1,3] 。
3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,1] 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1,1,1]
输出：0
解释：nums 中的所有元素已经是相等的。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [1,1,2,2,3]
输出：4
解释：需要 4 次操作使 nums 中的所有元素相等：
1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,2] 。
2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,1,2,2] 。 
3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,1,2] 。 
4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,1] 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>1 &lt;= nums[i] &lt;= 5 * 10^4</code></li>
</ul>
<h3 id="思路-33"><a class="header" href="#思路-33">思路</a></h3>
<p>排序，每次迭代找出第一大的和第二大的值，把第一大的值变成第二大的值。</p>
<p>假设第一大的个数为m,第二大的个数为n,变化需要的次数为m，变化后第二大的值为m+n。</p>
<p>当所有元素相等时结束迭代。</p>
<h3 id="代码-33"><a class="header" href="#代码-33">代码</a></h3>
<pre><code class="language-java">public class N2 {
    public int reductionOperations(int[] nums) {
        Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();
        PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;((o1, o2) -&gt; Integer.compare(o2,o1));
        for (int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        pq.addAll(map.keySet());
        int res=0;
        while (map.size()!=1){
            final int max = pq.poll();
            final int min = pq.poll();
            int m=map.get(max);
            int n=map.get(min);
            res+=m;
            pq.add(min);
            map.remove(max);
            map.put(min,m+n);
        }
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsminimum-number-of-flips-to-make-the-binary-string-alternating使二进制字符串字符交替的最少反转次数a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsminimum-number-of-flips-to-make-the-binary-string-alternating使二进制字符串字符交替的最少反转次数a">题三 <a href="https://leetcode-cn.com/contest/weekly-contest-244/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/">使二进制字符串字符交替的最少反转次数</a></a></h2>
<h3 id="描述-34"><a class="header" href="#描述-34">描述</a></h3>
<p>给你一个二进制字符串 <code>s</code> 。你可以按任意顺序执行以下两种操作任意次：</p>
<ul>
<li><strong>类型 1 ：删除</strong> 字符串 <code>s</code> 的第一个字符并将它 <strong>添加</strong> 到字符串结尾。</li>
<li><strong>类型 2 ：选择</strong> 字符串 <code>s</code> 中任意一个字符并将该字符 <strong>反转</strong> ，也就是如果值为 <code>'0'</code> ，则反转得到 <code>'1'</code> ，反之亦然。</li>
</ul>
<p>请你返回使 <code>s</code> 变成 <strong>交替</strong> 字符串的前提下， <strong>类型 2</strong> 的 <strong>最少</strong> 操作次数 。</p>
<p>我们称一个字符串是 <strong>交替</strong> 的，需要满足任意相邻字符都不同。</p>
<ul>
<li>比方说，字符串 <code>&quot;010&quot;</code> 和 <code>&quot;1010&quot;</code> 都是交替的，但是字符串 <code>&quot;0100&quot;</code> 不是。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;111000&quot;
输出：2
解释：执行第一种操作两次，得到 s = &quot;100011&quot; 。
然后对第三个和第六个字符执行第二种操作，得到 s = &quot;101010&quot; 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：s = &quot;010&quot;
输出：0
解释：字符串已经是交替的。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：s = &quot;1110&quot;
输出：1
解释：对第二个字符执行第二种操作，得到 s = &quot;1010&quot; 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s[i]</code> 要么是 <code>'0'</code> ，要么是 <code>'1'</code> 。</li>
</ul>
<h3 id="思路-34"><a class="header" href="#思路-34">思路</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<h3 id="代码-34"><a class="header" href="#代码-34">代码</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<h2 id="题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsminimum-space-wasted-from-packaging装包裹的最小浪费空间a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomcontestweekly-contest-244problemsminimum-space-wasted-from-packaging装包裹的最小浪费空间a">题四 <a href="https://leetcode-cn.com/contest/weekly-contest-244/problems/minimum-space-wasted-from-packaging/">装包裹的最小浪费空间</a></a></h2>
<h3 id="描述-35"><a class="header" href="#描述-35">描述</a></h3>
<p>给你 <code>n</code> 个包裹，你需要把它们装在箱子里，<strong>每个箱子装一个包裹</strong>。总共有 <code>m</code> 个供应商提供 <strong>不同尺寸</strong> 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 <strong>小于等于</strong> 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。</p>
<p>包裹的尺寸用一个整数数组 <code>packages</code> 表示，其中 <code>packages[i]</code> 是第 <code>i</code> 个包裹的尺寸。供应商用二维数组 <code>boxes</code> 表示，其中 <code>boxes[j]</code> 是第 <code>j</code> 个供应商提供的所有箱子尺寸的数组。</p>
<p>你想要选择 <strong>一个供应商</strong> 并只使用该供应商提供的箱子，使得 <strong>总浪费空间最小</strong> 。对于每个装了包裹的箱子，我们定义 <strong>浪费的</strong> 空间等于 <code>箱子的尺寸 - 包裹的尺寸</code> 。<strong>总浪费空间</strong> 为 <strong>所有</strong> 箱子中浪费空间的总和。</p>
<ul>
<li>比方说，如果你想要用尺寸数组为 <code>[4,8]</code> 的箱子装下尺寸为 <code>[2,3,5]</code> 的包裹，你可以将尺寸为 <code>2</code> 和 <code>3</code> 的两个包裹装入两个尺寸为 <code>4</code> 的箱子中，同时把尺寸为 <code>5</code> 的包裹装入尺寸为 <code>8</code> 的箱子中。总浪费空间为 <code>(4-2) + (4-3) + (8-5) = 6</code> 。</li>
</ul>
<p>请你选择 <strong>最优</strong> 箱子供应商，使得 <strong>总浪费空间最小</strong> 。如果 <strong>无法</strong> 将所有包裹放入箱子中，请你返回 <code>-1</code> 。由于答案可能会 <strong>很大</strong> ，请返回它对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：packages = [2,3,5], boxes = [[4,8],[2,8]]
输出：6
解释：选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。
总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]]
输出：-1
解释：没有箱子能装下尺寸为 5 的包裹。
</code></pre>
<p><strong>示例 3：</strong></p>
<pre><code>输入：packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]]
输出：9
解释：选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。
总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == packages.length</code></li>
<li><code>m == boxes.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= m &lt;= 105</code></li>
<li><code>1 &lt;= packages[i] &lt;= 105</code></li>
<li><code>1 &lt;= boxes[j].length &lt;= 105</code></li>
<li><code>1 &lt;= boxes[j][k] &lt;= 105</code></li>
<li><code>sum(boxes[j].length) &lt;= 105</code></li>
<li><code>boxes[j]</code> 中的元素 <strong>互不相同</strong> 。</li>
</ul>
<h3 id="思路-35"><a class="header" href="#思路-35">思路</a></h3>
<p>二分超时</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<h3 id="代码-35"><a class="header" href="#代码-35">代码</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/9O0fYc.jpg" alt="9O0fYc" /></p>
<p>超时代码</p>
<pre><code class="language-java">public class N4 {
    //TODO: TimeOut
    private final static int MOD= (int) (Math.pow(10,9)+7);
    public int minWastedSpace(int[] packages, int[][] boxes) {
        Map&lt;Integer,Integer&gt; pack=new HashMap&lt;&gt;(packages.length*2+5);
        int pMax=0;
        for (int p:packages){
            pack.put(p,pack.getOrDefault(p,0)+1);
            pMax=Math.max(pMax,p);
        }
        long res=Long.MAX_VALUE;
        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list=new ArrayList&lt;&gt;(pack.entrySet());
        list.sort(Comparator.comparingInt(Map.Entry::getKey));
        for (int[] box:boxes){
            int bMax=0;
            for (int j : box) {
                bMax = Math.max(bMax, j);
            }
            if(bMax&gt;=pMax){
                Arrays.sort(box);
                res=Math.min(res,slove(box,list,res));
            }
        }
        return res==Long.MAX_VALUE?-1: (int) (res % MOD);
    }

    private long slove(final int[] box,List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list , long max) {
        long res=0;
        int l=0;
        for (Map.Entry&lt;Integer,Integer&gt; e:list){
            int idx=find(e.getKey(),box,l);
            res+= (long) (box[idx] - e.getKey()) *e.getValue();
            if(res&gt;=max)return res;
            l=idx;
        }
        return res;
    }

    private int find(int key, int[] box,int l) {
        int left=l;
        int right=box.length-1;
        int res=box.length-1;
        while (left&lt;=right){
            int mid=left+(right-left)/2;
            if(box[mid]==key)return mid;
            else if(box[mid]&gt;key){
                res=mid;
                right=mid-1;
            }
            else left=mid+1;
        }
        return res;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第252场周赛"><a class="header" href="#力扣第252场周赛">力扣第252场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemsthree-divisors三除数a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemsthree-divisors三除数a">题一 <a href="https://leetcode-cn.com/problems/three-divisors/">三除数</a></a></h2>
<h3 id="描述-36"><a class="header" href="#描述-36">描述</a></h3>
<p>给你一个整数 n 。如果 n 恰好有三个正除数 ，返回 true ；否则，返回 false 。</p>
<p>如果存在整数 k ，满足 n = k * m ，那么整数 m 就是 n 的一个 除数 。</p>
<h3 id="思路-36"><a class="header" href="#思路-36">思路</a></h3>
<p>直接遍历。。。</p>
<h3 id="代码-36"><a class="header" href="#代码-36">代码</a></h3>
<pre><code class="language-java">public class N1 {
  public boolean isThree(int n) {
    int res = 0;
    for (int i=1;i&lt;=n;i++){
      if(n%i==0)res++;
      if(res&gt;3)return false;
    }
    return res==3;
  }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsmaximum-number-of-weeks-for-which-you-can-work你可以工作的最大周数a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsmaximum-number-of-weeks-for-which-you-can-work你可以工作的最大周数a">题二 <a href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/">你可以工作的最大周数</a></a></h2>
<h3 id="描述-37"><a class="header" href="#描述-37">描述</a></h3>
<p>给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。</p>
<p>你可以按下面两个规则参与项目中的工作：</p>
<p>每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。
在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>
<p>返回在不违反上面规则的情况下你 最多 能工作多少周。</p>
<p>示例 1：</p>
<p>输入：milestones = [1,2,3]
输出：6
解释：一种可能的情形是：</p>
<ul>
<li>
<p>第 1 周，你参与并完成项目 0 中的一个阶段任务。</p>
</li>
<li>
<p>第 2 周，你参与并完成项目 2 中的一个阶段任务。</p>
</li>
<li>
<p>第 3 周，你参与并完成项目 1 中的一个阶段任务。</p>
</li>
<li>
<p>第 4 周，你参与并完成项目 2 中的一个阶段任务。</p>
</li>
<li>
<p>第 5 周，你参与并完成项目 1 中的一个阶段任务。</p>
</li>
<li>
<p>第 6 周，你参与并完成项目 2 中的一个阶段任务。
总周数是 6 。</p>
</li>
</ul>
<p>示例 2:</p>
<p>输入：milestones = [5,2,1]
输出：7
解释：一种可能的情形是：</p>
<ul>
<li>第 1 周，你参与并完成项目 0 中的一个阶段任务。</li>
<li>第 2 周，你参与并完成项目 1 中的一个阶段任务。</li>
<li>第 3 周，你参与并完成项目 0 中的一个阶段任务。</li>
<li>第 4 周，你参与并完成项目 1 中的一个阶段任务。</li>
<li>第 5 周，你参与并完成项目 0 中的一个阶段任务。</li>
<li>第 6 周，你参与并完成项目 2 中的一个阶段任务。</li>
<li>第 7 周，你参与并完成项目 0 中的一个阶段任务。
总周数是 7 。
注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。
因此，项目 0 中会有一个阶段任务维持未完成状态。</li>
</ul>
<h3 id="思路-37"><a class="header" href="#思路-37">思路</a></h3>
<blockquote>
<p>这题最初的想法也是贪心，不过贪的方向错了。</p>
</blockquote>
<p>正确的思路：</p>
<p>如果阶段任务最多的项目可以完成，那么其他项目必定可以全部完成。</p>
<p>如果不可以完成，那么在剩余其它i个项目中可以填充<code>i+1</code>个位置给任务最多的项目,所以此时的周数为2*i+1。</p>
<p>直接计算两种情况，选小的那个就是真实情况。</p>
<h3 id="代码-37"><a class="header" href="#代码-37">代码</a></h3>
<pre><code class="language-java">/**
 * @author mikusugar
 */
public class N2 {

  public long numberOfWeeks(int[] milestones) {
    long sum=0;
    long max=-1;
    for (int i:milestones){
      sum+=i;
      max=Math.max(i,max);
    }
    long i = sum-max;
    return Math.min(sum,i*2+1);
  }

}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsminimum-garden-perimeter-to-collect-enough-apples收集足够苹果的最小花园周长a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsminimum-garden-perimeter-to-collect-enough-apples收集足够苹果的最小花园周长a">题三 <a href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples/">收集足够苹果的最小花园周长</a></a></h2>
<h3 id="描述-38"><a class="header" href="#描述-38">描述</a></h3>
<p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。</p>
<p>你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。</p>
<p>给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。</p>
<p>|x| 的值定义为：</p>
<p>如果 x &gt;= 0 ，那么值为 x
如果 x &lt; 0 ，那么值为 -x</p>
<p>示例 1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/2021/08/IkeiTa.jpg" alt="IkeiTa" /></p>
<p>输入：neededApples = 1
输出：8
解释：边长长度为 1 的正方形不包含任何苹果。
但是边长为 2 的正方形包含 12 个苹果（如上图所示）。
周长为 2 * 4 = 8 。
示例 2：</p>
<p>输入：neededApples = 13
输出：16
示例 3：</p>
<p>输入：neededApples = 1000000000
输出：5040</p>
<h3 id="思路-38"><a class="header" href="#思路-38">思路</a></h3>
<p>易得出最外一圈的计算公式，假设i为边离中心点的距离。</p>
<pre><code>((i+2*i)*(i+1)-i)*4-(i*2)*4
</code></pre>
<h3 id="代码-38"><a class="header" href="#代码-38">代码</a></h3>
<pre><code class="language-java">/**
 * @author mikusugar
 */
public class N3 {
  public long minimumPerimeter(long neededApples) {
    long sum=0;
    long res=0;
    while (sum&lt;neededApples){
      res++;
      sum+=help(res);
    }
    return res*2*4;
  }

  private long help(long i) {
    return ((i+2*i)*(i+1)-i)*4-(i*2)*4;
  }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemscount-number-of-special-subsequences统计特殊子序列的数目a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemscount-number-of-special-subsequences统计特殊子序列的数目a">题四 <a href="https://leetcode-cn.com/problems/count-number-of-special-subsequences/">统计特殊子序列的数目</a></a></h2>
<h3 id="描述-39"><a class="header" href="#描述-39">描述</a></h3>
<p>特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。</p>
<p>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。
相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。
给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</p>
<p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。</p>
<p>示例 1：</p>
<p>输入：nums = [0,1,2,2]
输出：3
解释：特殊子序列为 [0,1,2,2]，[0,1,2,2] 和 [0,1,2,2] 。
示例 2：</p>
<p>输入：nums = [2,2,0,0]
输出：0
解释：数组 [2,2,0,0] 中没有特殊子序列。
示例 3：</p>
<p>输入：nums = [0,1,2,0,1,2]
输出：7
解释：特殊子序列包括：</p>
<ul>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
<li>[0,1,2,0,1,2]</li>
</ul>
<h3 id="思路-39"><a class="header" href="#思路-39">思路</a></h3>
<p><strong>最初错误的想法❌。</strong></p>
<pre><code class="language-java">//最初的思路是DP，dp[3][nums.len],不过TimeOut了。
//超时的代码：
private final static int MOD = (int) (1e9+7);
  public int countSpecialSubsequences(int[] nums) {

    List&lt;Integer&gt;[] numslist = new List[3];
    for (int i=0;i&lt;numslist.length;i++)numslist[i]=new ArrayList&lt;&gt;();

    for (int i=0;i&lt;nums.length;i++){
      if(nums[i]==0)numslist[0].add(i);
      else if(nums[i]==1)numslist[1].add(i);
      else if(nums[i]==2)numslist[2].add(i);
    }


    long[][] dp = new long[3][nums.length];
    for (int i=0;i&lt;3;i++) Arrays.fill(dp[i],-1);
    long res=0;
    for (int i=0;i&lt; nums.length;i++){
      if(nums[i]==0){
        res+=slove(0,i, dp,numslist);
        res%=MOD;
      }
    }
    return (int) res;
  }

  private long slove(int num, int idx, long[][] dp, List&lt;Integer&gt;[] numslist) {
    if(dp[num][idx]!=-1)return dp[num][idx];
    long res=0;
    if(num==2)res++;
    for (int i=numslist[num].size()-1;i&gt;=0&amp;&amp;numslist[num].get(i)&gt;idx;i--){
      int next = numslist[num].get(i);
      res+=slove(num,next, dp,numslist);
    }
    if(num&lt;2){
      for (int i=numslist[num+1].size()-1;i&gt;=0&amp;&amp;numslist[num+1].get(i)&gt;idx;i--){
        int next = numslist[num+1].get(i);
        res+=slove(num+1,next, dp,numslist);
      }
    }
    return dp[num][idx]=res;
  }
</code></pre>
<p><strong>正确思路：</strong></p>
<p>也是分为3种情况:</p>
<ul>
<li>全是0的串 a</li>
<li>01组成的串 b</li>
<li>012组成的串 c</li>
</ul>
<p>可以得到：</p>
<ul>
<li>如果当前位是0,a+=a+1</li>
<li>如果当前位是1,b+=a+b</li>
<li>如果当前位是2,c+=b+c</li>
</ul>
<h3 id="代码-39"><a class="header" href="#代码-39">代码</a></h3>
<pre><code class="language-java"> private final static int MOD = (int) (1e9+7);
 public int countSpecialSubsequences(int[] nums) {
    int a=0,b=0,c=0;
    for (int i:nums){
      if(i==0){
        a+=a+1;
      }
      else if(i==1){
        b+=a+b;
      }
      else if(i==2){
        c+=b+c;
      }
    }
    return c;
 }
</code></pre>
<h2 id="其它-1"><a class="header" href="#其它-1">其它</a></h2>
<p>太久没打了，虽然有两题解决的思路大体是一样的，但是想复杂了（就是菜。。。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力扣第253场周赛"><a class="header" href="#力扣第253场周赛">力扣第253场周赛</a></h1>
<h2 id="题一-a-hrefhttpsleetcode-cncomproblemscheck-if-string-is-a-prefix-of-array检查字符串是否为数组前缀a"><a class="header" href="#题一-a-hrefhttpsleetcode-cncomproblemscheck-if-string-is-a-prefix-of-array检查字符串是否为数组前缀a">题一 <a href="https://leetcode-cn.com/problems/check-if-string-is-a-prefix-of-array/">检查字符串是否为数组前缀</a></a></h2>
<h3 id="描述-40"><a class="header" href="#描述-40">描述</a></h3>
<p>给你一个字符串 s 和一个字符串数组 words ，请你判断 s 是否为 words 的 前缀字符串 。</p>
<p>字符串 s 要成为 words 的 前缀字符串 ，需要满足：s 可以由 words 中的前 k（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 words.length 。</p>
<p>如果 s 是 words 的 前缀字符串 ，返回 true ；否则，返回 false 。</p>
<p>示例 1：</p>
<p>输入：s = &quot;iloveleetcode&quot;, words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;apples&quot;]
输出：true
解释：
s 可以由 &quot;i&quot;、&quot;love&quot; 和 &quot;leetcode&quot; 相连得到。
示例 2：</p>
<p>输入：s = &quot;iloveleetcode&quot;, words = [&quot;apples&quot;,&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;]
输出：false
解释：
数组的前缀相连无法得到 s 。</p>
<h3 id="思路-40"><a class="header" href="#思路-40">思路</a></h3>
<p>直接遍历。</p>
<h3 id="代码-40"><a class="header" href="#代码-40">代码</a></h3>
<pre><code class="language-java">/**
 * @author mikusugar
 */
public class N1 {
    public boolean isPrefixString(String s, String[] words) {
        final StringBuilder sb = new StringBuilder();
        for (String str : words) {
            sb.append(str);
            if (sb.toString().equals(s)) return true;
        }
        return false;
    }
}
</code></pre>
<h2 id="题二-a-hrefhttpsleetcode-cncomproblemsremove-stones-to-minimize-the-total移除石子使总数最小a"><a class="header" href="#题二-a-hrefhttpsleetcode-cncomproblemsremove-stones-to-minimize-the-total移除石子使总数最小a">题二 <a href="https://leetcode-cn.com/problems/remove-stones-to-minimize-the-total/">移除石子使总数最小</a></a></h2>
<h3 id="描述-41"><a class="header" href="#描述-41">描述</a></h3>
<p>给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：</p>
<p>选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] / 2) 颗石子。
注意：你可以对 同一堆 石子多次执行此操作。</p>
<p>返回执行 k 次操作后，剩下石子的 最小 总数。</p>
<p>floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。</p>
<p>示例 1：</p>
<p>输入：piles = [5,4,9], k = 2
输出：12
解释：可能的执行情景如下：</p>
<ul>
<li>对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。</li>
<li>对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。
剩下石子的总数为 12 。
示例 2：</li>
</ul>
<p>输入：piles = [4,3,6,7], k = 3
输出：12
解释：可能的执行情景如下：</p>
<ul>
<li>对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。</li>
<li>对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。</li>
<li>对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。
剩下石子的总数为 12 。</li>
</ul>
<p>提示：</p>
<p>1 &lt;= piles.length &lt;= 10^5
1 &lt;= piles[i] &lt;= 10^4
1 &lt;= k &lt;= 10^5</p>
<h3 id="思路-41"><a class="header" href="#思路-41">思路</a></h3>
<p>贪心，每次选当前最大的堆。</p>
<p>用优先队列。</p>
<h3 id="代码-41"><a class="header" href="#代码-41">代码</a></h3>
<pre><code class="language-java">import java.util.PriorityQueue;

/**
 * @author mikusugar
 */
public class N2 {
    public int minStoneSum(int[] piles, int k) {
        final PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; Integer.compare(o2, o1));
        for (int num : piles) pq.add(num);
        while (k-- &gt; 0) {
            final int cur = pq.poll();
            pq.add(cur - (int) Math.floor(cur / 2.0));
        }
        int res = 0;
        while (!pq.isEmpty()) res += pq.poll();
        return res;
    }
}
</code></pre>
<h2 id="题三-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-string-balanced使字符串平衡的最小交换次数a"><a class="header" href="#题三-a-hrefhttpsleetcode-cncomproblemsminimum-number-of-swaps-to-make-the-string-balanced使字符串平衡的最小交换次数a">题三 <a href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/">使字符串平衡的最小交换次数</a></a></h2>
<h3 id="描述-42"><a class="header" href="#描述-42">描述</a></h3>
<p>给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。</p>
<p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p>
<p>字符串是一个空字符串，或者
字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。
你可以交换 任意 两个下标所对应的括号 任意 次数。</p>
<p>返回使 s 变成 平衡字符串 所需要的 最小 交换次数。</p>
<p>示例 1：</p>
<p>输入：s = &quot;][][&quot; 输出：1 解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。 最终字符串变成 &quot;[[]]&quot; 。
示例 2：</p>
<p>输入：s = &quot;]]][[[&quot;
输出：2
解释：执行下述操作可以使字符串变成平衡字符串：</p>
<ul>
<li>交换下标 0 和下标 4 对应的括号，s = &quot;[]][[]&quot; 。</li>
<li>交换下标 1 和下标 5 对应的括号，s = &quot;[[][]]&quot; 。
最终字符串变成 &quot;[[][]]&quot; 。
示例 3：</li>
</ul>
<p>输入：s = &quot;[]&quot;
输出：0
解释：这个字符串已经是平衡字符串。</p>
<h3 id="思路-42"><a class="header" href="#思路-42">思路</a></h3>
<p>找规律。</p>
<blockquote>
<p>交换一次最多可以令两对配对。</p>
</blockquote>
<p>令无法配对的对数为f，可得 res=f/2+f%2;</p>
<h3 id="代码-42"><a class="header" href="#代码-42">代码</a></h3>
<pre><code class="language-java">/**
 * @author mikusugar
 */
public class N3 {
    public int minSwaps(String s) {
        int f = 0;
        int a = 0;
        int b = 0;
        final char[] strs = s.toCharArray();
        for (char c : strs) {
            if (c == ']') {
                a++;
                if (a &gt; b) {
                    f++;
                    a--;
                }
            } else b++;
        }
        return f / 2 + f % 2;
    }
}
</code></pre>
<h2 id="题四-a-hrefhttpsleetcode-cncomproblemsfind-the-longest-valid-obstacle-course-at-each-position找出到每个位置为止最长的有效障碍赛跑路线a"><a class="header" href="#题四-a-hrefhttpsleetcode-cncomproblemsfind-the-longest-valid-obstacle-course-at-each-position找出到每个位置为止最长的有效障碍赛跑路线a">题四 <a href="https://leetcode-cn.com/problems/find-the-longest-valid-obstacle-course-at-each-position/">找出到每个位置为止最长的有效障碍赛跑路线</a></a></h2>
<h3 id="描述-43"><a class="header" href="#描述-43">描述</a></h3>
<p>你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。</p>
<p>对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标  i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度：</p>
<p>你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。
在这条路线中，必须包含第 i 个障碍。
你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。
除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。
返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。</p>
<p>示例 1：</p>
<p>输入：obstacles = [1,2,3,2]
输出：[1,2,3,3]
解释：每个位置的最长有效障碍路线是：</p>
<ul>
<li>i = 0: [1], [1] 长度为 1</li>
<li>i = 1: [1,2], [1,2] 长度为 2</li>
<li>i = 2: [1,2,3], [1,2,3] 长度为 3</li>
<li>i = 3: [1,2,3,2], [1,2,2] 长度为 3
示例 2：</li>
</ul>
<p>输入：obstacles = [2,2,1]
输出：[1,2,1]
解释：每个位置的最长有效障碍路线是：</p>
<ul>
<li>i = 0: [2], [2] 长度为 1</li>
<li>i = 1: [2,2], [2,2] 长度为 2</li>
<li>i = 2: [2,2,1], [1] 长度为 1
示例 3：</li>
</ul>
<p>输入：obstacles = [3,1,5,6,4,2]
输出：[1,1,2,3,2,2]
解释：每个位置的最长有效障碍路线是：</p>
<ul>
<li>i = 0: [3], [3] 长度为 1</li>
<li>i = 1: [3,1], [1] 长度为 1</li>
<li>i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线</li>
<li>i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线</li>
<li>i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线</li>
<li>i = 5: [3,1,5,6,4,2], [1,2] 长度为 2</li>
</ul>
<h3 id="思路-43"><a class="header" href="#思路-43">思路</a></h3>
<p>仔细看题目得出，这题就是求最长递增子序列。。。</p>
<p>直接动态规划<code>：O(n^2)</code>没有通过，二分加贪心通过<code>O(nlogn)</code>。</p>
<h3 id="代码-43"><a class="header" href="#代码-43">代码</a></h3>
<pre><code class="language-java">/**
 * @author mikusugar
 */
public class N4 {
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int maxL = 0;
        int[] dp = new int[obstacles.length];
        int[] ans = new int[obstacles.length];
        for (int i = 0; i &lt; obstacles.length; i++) {
            int num = obstacles[i];
            int left = 0, right = maxL;
            while (left &lt; right) {
                int mid = left + (right - left) / 2;
                if (dp[mid] &lt;= num)
                    left = mid + 1;
                else
                    right = mid;
            }
            dp[left] = num;
            if (left == maxL) {
                maxL++;
            }
            ans[i] = left + 1;
        }
        return ans;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具"><a class="header" href="#工具">工具</a></h1>
<p>一些日常工具使用笔记～</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">git</a></h1>
<p>关于git的一些笔记～</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-flow"><a class="header" href="#git-flow">git flow</a></h1>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<pre><code class="language-bash">brew install git-flow-avh
</code></pre>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/mikusugar/PictureBed@master/uPic/OZH3W0.jpg" alt="命令" /></p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<pre><code class="language-bash">git flow init 
</code></pre>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<h4 id="增加新特性"><a class="header" href="#增加新特性">增加新特性</a></h4>
<p>新特性的开发是基于 'develop' 分支的。</p>
<p>通过下面的命令开始开发新特性：</p>
<pre><code class="language-bash">git flow feature start MYFEATURE
</code></pre>
<p>这个操作创建了一个基于'develop'的特性分支，并切换到这个分支之下。</p>
<h4 id="完成新特性"><a class="header" href="#完成新特性">完成新特性</a></h4>
<p>完成开发新特性。这个动作执行下面的操作.</p>
<ul>
<li>合并 MYFEATURE 分支到 'develop'</li>
<li>删除这个新特性分支</li>
<li>切换回 'develop' 分支</li>
</ul>
<pre><code class="language-bash">git flow feature finish MYFEATURE
</code></pre>
<h4 id="发布新特性"><a class="header" href="#发布新特性">发布新特性</a></h4>
<p>发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。</p>
<pre><code class="language-bash">git flow feature publish MYFEATURE
</code></pre>
<h4 id="取得一个发布的新特性分支"><a class="header" href="#取得一个发布的新特性分支">取得一个发布的新特性分支</a></h4>
<p>取得其它用户发布的新特性分支，并签出远程的变更。</p>
<pre><code class="language-bash">git flow feature pull origin MYFEATURE
</code></pre>
<p>使用下列命令追踪origin上的特性分支</p>
<pre><code class="language-bash">git flow feature track MYFEATURE
</code></pre>
<h3 id="release"><a class="header" href="#release">release</a></h3>
<h4 id="准备release"><a class="header" href="#准备release">准备release</a></h4>
<p>它从 'develop' 分支开始创建一个 release 分支。</p>
<pre><code class="language-bash">git flow release start RELEASE [BASE]
</code></pre>
<p>你可以选择提供一个 <code>[BASE]</code>参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是'develop' 分支下的。</p>
<h4 id="发布release"><a class="header" href="#发布release">发布release</a></h4>
<pre><code class="language-bash">git flow release publish RELEASE
</code></pre>
<p>通过以下命令签出release版本的远程变更</p>
<pre><code class="language-bash">git flow release track RELEASE
</code></pre>
<h4 id="完成release"><a class="header" href="#完成release">完成release</a></h4>
<p>完成 release 版本是一个大 git 分支操作。它执行下面几个动作：</p>
<ul>
<li>归并 release 分支到 'master' 分支</li>
<li>用 release 分支名打 Tag</li>
<li>归并 release 分支到 'develop'</li>
<li>移除 release 分支</li>
</ul>
<pre><code class="language-bash">git flow release finish RELEASE
</code></pre>
<h3 id="紧急修复"><a class="header" href="#紧急修复">紧急修复</a></h3>
<h4 id="开始紧急修复"><a class="header" href="#开始紧急修复">开始紧急修复</a></h4>
<pre><code class="language-bash">git flow hotfix start VERSION [BASENAME]
</code></pre>
<p>VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，<code>[BASENAME]</code>为finish release时填写的版本号</p>
<h4 id="完成紧急修复"><a class="header" href="#完成紧急修复">完成紧急修复</a></h4>
<p>当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p>
<pre><code class="language-bash">git flow hotfix finish VERSION
</code></pre>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p>http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux"><a class="header" href="#linux">linux</a></h1>
<p>记录Linux相关。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试硬盘性能"><a class="header" href="#测试硬盘性能">测试硬盘性能</a></h1>
<h2 id="linux上测试"><a class="header" href="#linux上测试">Linux上测试</a></h2>
<p>使用<code>dd</code> 命令简单测试硬盘写</p>
<pre><code class="language-shell">dd if=/dev/zero of=/data/disk1/tmp/test1.img bs=1G count=1 oflag=dsync
</code></pre>
<p>参数解释 </p>
<ul>
<li><code>if=/dev/zero</code> (if=/dev/input.file) ：用来设置dd命令读取的输入文件名。</li>
<li><code>of=/data/disk1/tmp/test1.img</code> (of=/path/to/output.file)：dd命令将input.file写入的输出文件的名字。</li>
<li><code>bs=1G</code> (bs=block-size) ：设置dd命令读取的块的大小。例子中为1个G;bs选项的默认单位是bytes</li>
<li><code>count=1</code> (count=number-of-blocks)：dd命令读取的块的个数。</li>
<li><code>oflag=dsync</code> (oflag=dsync) ：使用同步I/O。不要省略这个选项。这个选项能够帮助你去除caching的影响，以便呈现给你精准的结果。</li>
<li><code>conv=fdatasyn</code>: 这个选项和<code>oflag=dsync</code>含义一样。</li>
</ul>
<p>使用<code>dd</code>命令测试硬盘读</p>
<p>例子：</p>
<pre><code class="language-shell">dd if=/dev/zero of=/tmp/laptop.bin bs=4K count=1000 oflag=direct
</code></pre>
<p>普通HDD速度:</p>
<table><thead><tr><th>文件信息</th><th>写速度</th><th>读速度</th></tr></thead><tbody>
<tr><td>1G</td><td>134MB/S</td><td>141MB/S</td></tr>
<tr><td>512bytes*1000</td><td>265KB/S</td><td>500kB/S</td></tr>
<tr><td>4k*1000</td><td>2.1MB/S</td><td>4.5MB/S</td></tr>
<tr><td>8k*1000</td><td>4.2MB/S</td><td>8.6MB/S</td></tr>
</tbody></table>
<p>AWS EBS速度（t3.micro）:</p>
<table><thead><tr><th>文件信息</th><th>写速度</th><th>读速度</th></tr></thead><tbody>
<tr><td>300MB</td><td>219MB/S</td><td>166MB/S</td></tr>
<tr><td>512bytes*1000</td><td>382kb/S</td><td>719kB/S</td></tr>
<tr><td>4k*1000</td><td>3.3MB/S</td><td>6.5MB/S</td></tr>
<tr><td>8k*1000</td><td>6.7MB/S</td><td>12.4MB/S</td></tr>
</tbody></table>
<h2 id="mac-上测试"><a class="header" href="#mac-上测试">Mac 上测试</a></h2>
<p>Mac 上的dd命令 单位是小写，如GB位g，MB位m。</p>
<p>跑命令前先执行清空缓存。</p>
<pre><code class="language-shell">sudo purge
</code></pre>
<p>写例子：</p>
<pre><code class="language-shell">dd if=/dev/zero of=test1.img bs=1g count=1 2&gt;&amp;1 | grep sec | awk '{print $1 / 1024 / 1024 / $5, &quot;MB/sec&quot; }'
</code></pre>
<p>读例子：</p>
<pre><code class="language-shell">dd if=tstfile bs=1g of=/dev/null count=1 2&gt;&amp;1 | grep sec | awk '{print $1 / 1024 / 1024 / $5, &quot;MB/sec&quot; }'
</code></pre>
<p>M1 MacBook pro 2020 SSD速度</p>
<table><thead><tr><th>文件信息</th><th>写速度</th><th>读速度</th></tr></thead><tbody>
<tr><td>1G</td><td>2532.73 MB/S</td><td>3367.79 MB/S</td></tr>
<tr><td>512bytes*1000</td><td>20MB/S</td><td>258.487 MB/S</td></tr>
<tr><td>4k*1000</td><td>823.93MB/S</td><td>955.307 MB/S</td></tr>
<tr><td>8k*1000</td><td>1505.88MB/S</td><td>1521.72 MB/S</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="大数据"><a class="header" href="#大数据">大数据</a></h1>
<p>大数据相关笔记。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hive-metastore-java-api"><a class="header" href="#hive-metastore-java-api">hive metastore java api</a></h1>
<p>通过 hive metastore api查询元数据信息。</p>
<h2 id="依赖"><a class="header" href="#依赖">依赖</a></h2>
<pre><code class="language-xml"> &lt;dependency&gt;
      &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
      &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;
      &lt;version&gt;1.2.2&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.eclipse.jetty.aggregate&lt;/groupId&gt;
          &lt;artifactId&gt;jetty-all&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
      &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;
      &lt;version&gt;2.7.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
      &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;
      &lt;version&gt;1.2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;
      &lt;version&gt;1.20&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-java">import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.hive.conf.HiveConf;
import org.apache.hadoop.hive.metastore.IMetaStoreClient;
import org.apache.hadoop.hive.metastore.api.Table;
import org.apache.hadoop.hive.ql.metadata.HiveException;
import org.apache.thrift.TException;

public class Hive {

    public static void main(String[] args) throws TException, HiveException {
        final String hiveConfPath=&quot;/Users/mikusugar/code/test/jdk8_test/src/main/resources/conf/hive-site.xml&quot;;
        Configuration configuration = new Configuration();
        configuration.addResource(new Path(hiveConfPath));
        HiveConf hiveConf = new HiveConf(configuration, Hive.class);
        final IMetaStoreClient client = org.apache.hadoop.hive.ql.metadata.Hive.get(hiveConf).getMSC();
        System.out.println(client.getAllDatabases());
        final Table res = client.getTable(&quot;flink&quot;, &quot;flink_web_source&quot;);
        System.out.println(res.toString());
        client.close();
    }
}
</code></pre>
<p>拿到 <code>IMetaStoreClient</code>实例就可以愉快玩耍了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flink"><a class="header" href="#flink">FLINK</a></h1>
<h2 id="flink-相关的一些笔记"><a class="header" href="#flink-相关的一些笔记">flink 相关的一些笔记</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flink-任务提交入口"><a class="header" href="#flink-任务提交入口">Flink 任务提交入口</a></h1>
<h2 id="入口类"><a class="header" href="#入口类">入口类</a></h2>
<p><code>org.apache.flink.client.cli.CliFrontend</code></p>
<h3 id="main"><a class="header" href="#main">main</a></h3>
<pre><code class="language-java">public static void main(final String[] args) {
		EnvironmentInformation.logEnvironmentInfo(LOG, &quot;Command Line Client&quot;, args);

		// 1. find the configuration directory
		/*获取flink的conf目录的路径*/
		final String configurationDirectory = getConfigurationDirectoryFromEnv();

		// 2. load the global configuration
		/*据conf路径，加载配置*/
		final Configuration configuration = GlobalConfiguration.loadConfiguration(configurationDirectory);

		// 3. load the custom command lines
		/*封装命令行接口：按顺序Generic、Yarn、Default*/
		final List&lt;CustomCommandLine&gt; customCommandLines = loadCustomCommandLines(
			configuration,
			configurationDirectory);

		try {
			final CliFrontend cli = new CliFrontend(
				configuration,
				customCommandLines);

			SecurityUtils.install(new SecurityConfiguration(cli.configuration));
			int retCode = SecurityUtils.getInstalledContext()
					.runSecured(() -&gt; cli.parseAndRun(args));
			System.exit(retCode);
		}
		catch (Throwable t) {
			final Throwable strippedThrowable = ExceptionUtils.stripException(t, UndeclaredThrowableException.class);
			LOG.error(&quot;Fatal error while running command line interface.&quot;, strippedThrowable);
			strippedThrowable.printStackTrace();
			System.exit(31);
		}
	}
</code></pre>

                    </main>


                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
                <div id="disqus_thread"></div>
                <script>
                    /**
                     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
                    /*
                    var disqus_config = function () {
                    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                    };
                    */
                    (function() { // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');
                        s.src = 'https://mikusugar-me.disqus.com/embed.js';
                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
